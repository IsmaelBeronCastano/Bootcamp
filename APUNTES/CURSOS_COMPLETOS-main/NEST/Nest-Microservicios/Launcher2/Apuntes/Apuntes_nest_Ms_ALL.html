<!DOCTYPE html>
<html>
<head>
<title>Apuntes_nest_Ms_ALL.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="01--nest-microservicios---gateway-y-manejo-de-errores">01- NEST MICROSERVICIOS - Gateway y Manejo de Errores</h1>
<ul>
<li>El primer microservicio lo trabajaremos con SQLite (productos)</li>
<li>products/entities/product.entity</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span> </span>{


  public id: number;

  public name: string;

  public price: number;

}
</div></code></pre>
<ul>
<li>Hay que instalar class-validator y class-transformer</li>
<li>También hay que configurarlo en el main</li>
</ul>
<pre class="hljs"><code><div>  app.useGlobalPipes(
    <span class="hljs-keyword">new</span> ValidationPipe({
      <span class="hljs-attr">whitelist</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">forbidNonWhitelisted</span>: <span class="hljs-literal">true</span>,
    }),
  );
</div></code></pre>
<ul>
<li>products/dtos/create-product.dto</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Type } <span class="hljs-keyword">from</span> <span class="hljs-string">'class-transformer'</span>;
<span class="hljs-keyword">import</span> { IsNumber, IsString, Min } <span class="hljs-keyword">from</span> <span class="hljs-string">'class-validator'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateProductDto</span> </span>{

  @IsString()
  public name: string;

  @IsNumber({
    <span class="hljs-attr">maxDecimalPlaces</span>: <span class="hljs-number">4</span>, <span class="hljs-comment">//máximo de decimales</span>
  })
  @Min(<span class="hljs-number">0</span>)
  @Type(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">Number</span> ) <span class="hljs-comment">//lo casteo a número</span>
  public price: number;

}
</div></code></pre>
<hr>
<h2 id="configurar-variables-de-entorno">Configurar variables de entorno</h2>
<ul>
<li>Instalo dotenv y joi</li>
<li>/config/envs.ts</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> <span class="hljs-string">'dotenv/config'</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> joi <span class="hljs-keyword">from</span> <span class="hljs-string">'joi'</span>;

interface EnvVars {
  <span class="hljs-attr">PORT</span>: number;
  DATABASE_URL: string;
}

<span class="hljs-keyword">const</span> envsSchema = joi.object({
  <span class="hljs-attr">PORT</span>: joi.number().required(),
  <span class="hljs-attr">DATABASE_URL</span>: joi.string().required(),
})
.unknown(<span class="hljs-literal">true</span>); <span class="hljs-comment">//hay muchas más variables de entorno flotando en mi aplicación (el path de node, etc)</span>


<span class="hljs-comment">//hago la validación extrayendo los valores con desestructuración</span>
<span class="hljs-keyword">const</span> { error, value } = envsSchema.validate( process.env );


<span class="hljs-keyword">if</span> ( error ) {
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Config validation error: <span class="hljs-subst">${ error.message }</span>`</span>);
}

<span class="hljs-comment">//En enVars de tipo Envars (interface) guardo los valores que desestructuré del Schema </span>
<span class="hljs-keyword">const</span> envVars:EnvVars = value;

<span class="hljs-comment">//Exporto las variables en un objeto</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> envs = {
  <span class="hljs-attr">port</span>: envVars.PORT,
  <span class="hljs-attr">databaseUrl</span>: envVars.DATABASE_URL,
}
</div></code></pre>
<ul>
<li>Es recomendable crear un snippet con este código (usar easySnippet)</li>
<li>Creo el .env y el .env.template</li>
</ul>
<pre class="hljs"><code><div>PORT=3001
DATABASE_URL=&quot;file:./dev.db&quot;
</div></code></pre>
<ul>
<li>Uso las variables donde corresponde (en el main, uso await app.listen(envs.port) )</li>
<li>Cuando configuremos el microservicio lo pondremos <strong>en otro lugar</strong></li>
</ul>
<hr>
<h2 id="prisma-sqlite">Prisma SQLite</h2>
<ul>
<li>Instalo prisma como dependencia de desarrollo (prisma crea un cliente)</li>
<li>Para inciar prisma</li>
</ul>
<blockquote>
<p>npx prisma init</p>
</blockquote>
<ul>
<li>Produjo una cadena de conexión para postgres en .env</li>
<li>Lo borro y coloco la de SqLite</li>
</ul>
<pre class="hljs"><code><div>DATABASE_URL=&quot;file:./dev.db&quot;
</div></code></pre>
<ul>
<li>En schema.prisma (instalar extensión de sintaxis de prisma)</li>
<li>Luce como js (o ts) pero no lo es! Es sintaxis propia de prisma</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// This is your Prisma schema file,</span>
<span class="hljs-comment">// learn more about it in the docs: https://pris.ly/d/prisma-schema</span>

<span class="hljs-comment">// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?</span>
<span class="hljs-comment">// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init</span>

generator client {
  provider = <span class="hljs-string">"prisma-client-js"</span>
}

datasource db {
  provider = <span class="hljs-string">"sqlite"</span>  <span class="hljs-comment">//La db!!</span>
  url      = env(<span class="hljs-string">"DATABASE_URL"</span>) <span class="hljs-comment">//le paso la variable de entorno</span>
}

model Product {
  id    Int    @id @<span class="hljs-keyword">default</span>(autoincrement()) <span class="hljs-comment">//Agrego un id autoincrementado, el Int va a ser el identificador de id (@id)</span>
  name  <span class="hljs-built_in">String</span>
  price Float

  available <span class="hljs-built_in">Boolean</span> @<span class="hljs-keyword">default</span>(<span class="hljs-literal">true</span>)

  createdAt DateTime @<span class="hljs-keyword">default</span>(now()) <span class="hljs-comment">//uso now para usar la fecha del momento</span>
  updatedAt DateTime @updatedAt

  @@index([available]) <span class="hljs-comment">//indexo avaliable para que no aparezcan en las búsquedas</span>
}
</div></code></pre>
<ul>
<li>Ejecuto la migración</li>
</ul>
<blockquote>
<p>npx prisma migrate dev --name init</p>
</blockquote>
<ul>
<li>Me crea la db</li>
<li>Instalo el @prisma/client</li>
<li>Voy al servicio y lo extiendo de PrismaCLient e implementaré OnModuleInit</li>
</ul>
<pre class="hljs"><code><div>@Injectable()
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductsService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PrismaClient</span> <span class="hljs-title">implements</span> <span class="hljs-title">OnModuleInit</span> </span>{
    
    onModuleInit() {
    <span class="hljs-keyword">this</span>.$connect();  <span class="hljs-comment">//Database connected!!</span>
  }
}
</div></code></pre>
<ul>
<li>Ya podemos empezar a trabajar con la DB</li>
<li>Puedo crear un logger para mejorar los logs</li>
</ul>
<pre class="hljs"><code><div>@Injectable()
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductsService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PrismaClient</span> <span class="hljs-title">implements</span> <span class="hljs-title">OnModuleInit</span> </span>{

  private readonly logger = <span class="hljs-keyword">new</span> Logger(<span class="hljs-string">'ProductsService'</span>); <span class="hljs-comment">//creo un logger con el cabezal de ProductsService</span>

  onModuleInit() {
    <span class="hljs-keyword">this</span>.$connect();
    <span class="hljs-keyword">this</span>.logger.log(<span class="hljs-string">'Database connected'</span>); <span class="hljs-comment">//mejoro el log!</span>
  }
}
</div></code></pre>
<ul>
<li>También lo uso en el main de la misma forma</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { NestFactory } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/core'</span>;
<span class="hljs-keyword">import</span> { AppModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.module'</span>;
<span class="hljs-keyword">import</span> { Logger, ValidationPipe } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { envs } <span class="hljs-keyword">from</span> <span class="hljs-string">'./config'</span>;
<span class="hljs-keyword">import</span> { MicroserviceOptions, Transport } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/microservices'</span>;

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bootstrap</span>(<span class="hljs-params"></span>) </span>{

  <span class="hljs-keyword">const</span> logger = <span class="hljs-keyword">new</span> Logger(<span class="hljs-string">'Main'</span>);

  <span class="hljs-comment">//const app = await NestFactory.createMicroservice&lt;MicroserviceOptions&gt;(</span>
    <span class="hljs-comment">//AppModule,</span>
    <span class="hljs-comment">//{</span>
      <span class="hljs-comment">//transport: Transport.TCP,</span>
      <span class="hljs-comment">//options: {</span>
        <span class="hljs-comment">//port: envs.port</span>
      <span class="hljs-comment">//}</span>
    <span class="hljs-comment">//}</span>
  <span class="hljs-comment">//);</span>

  app.useGlobalPipes(
    <span class="hljs-keyword">new</span> ValidationPipe({
      <span class="hljs-attr">whitelist</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">forbidNonWhitelisted</span>: <span class="hljs-literal">true</span>,
    }),
  );

  <span class="hljs-keyword">await</span> app.listen();
  logger.log(<span class="hljs-string">`Products Microservice running on port <span class="hljs-subst">${ envs.port }</span>`</span>); <span class="hljs-comment">//el logger!</span>

}
bootstrap();
</div></code></pre>
<hr>
<h2 id="insertar-y-comprobar-la-db">Insertar y comprobar la DB</h2>
<ul>
<li>createdAt ya tioene un valor por defecto</li>
<li>Creo el método create en el servicio</li>
<li>Es this.product porque la clase (el servicio) extiende de PrismaClient y el modelo se llama Product</li>
<li>Uso el método create para insertar. regresa una promesa con el registro insertado</li>
<li>El producto espera un name y un price</li>
</ul>
<pre class="hljs"><code><div>create(createProductDto: CreateProductDto) {

<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.product.create({
    <span class="hljs-attr">data</span>: createProductDto
});

}
</div></code></pre>
<ul>
<li>Para ver la DB puedo usar Abrir con.. &quot;TablePlus&quot;</li>
<li>Para añadir data en Table PLus crear la nueva conexión con SQLite e importar el archivo desde la interfaz</li>
</ul>
<hr>
<h2 id="obtener-productos-y-paginarlos">Obtener productos y paginarlos</h2>
<ul>
<li>Creo el dto de paginación en common/dto/pagination.dto</li>
<li>Hago ambos opcionales y casteo el tipo a number</li>
<li>Les pongo valores por defecto</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Type } <span class="hljs-keyword">from</span> <span class="hljs-string">'class-transformer'</span>;
<span class="hljs-keyword">import</span> { IsOptional, IsPositive } <span class="hljs-keyword">from</span> <span class="hljs-string">'class-validator'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaginationDto</span> </span>{

  @IsPositive()
  @IsOptional()
  @Type(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">Number</span>)
  page?: number = <span class="hljs-number">1</span>;

  @IsPositive()
  @IsOptional()
  @Type(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">Number</span>)
  limit?: number = <span class="hljs-number">10</span>;

}
</div></code></pre>
<ul>
<li>En el servicio</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">async</span> findAll( paginationDto: PaginationDto ) {

    <span class="hljs-keyword">const</span> { page, limit } = paginationDto;

    <span class="hljs-keyword">const</span> totalProducts = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.product.count({ <span class="hljs-attr">where</span>: { <span class="hljs-attr">available</span>: <span class="hljs-literal">true</span> } }); <span class="hljs-comment">//para contar los productos disponibles</span>
    <span class="hljs-keyword">const</span> lastPage = <span class="hljs-built_in">Math</span>.ceil( totalProducts / limit ); <span class="hljs-comment">//divido el total de páginas (número de productos disponibles) por el limite</span>
                                                     <span class="hljs-comment">//.ceil redondea al siguiente número positivo </span>

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">data</span>: <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.product.findMany({
        <span class="hljs-comment">//skip = 0 * (limit = 10) = 0 primera posición del arreglo páginas tengo 1,2,3</span>
        <span class="hljs-comment">//si estoy en la página 2 = (2-1) == 1 * limit ===10, skip 10 registros</span>

        <span class="hljs-attr">skip</span>: ( page - <span class="hljs-number">1</span> ) * limit,
        <span class="hljs-attr">take</span>: limit,
        <span class="hljs-attr">where</span>: {
          <span class="hljs-attr">available</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">//listo los que están disponibles</span>
        }
      }),
      <span class="hljs-comment">//meta de metadata</span>
      <span class="hljs-attr">meta</span>: {
        <span class="hljs-attr">total</span>: totalProducts, <span class="hljs-comment">//el resultado de .count de la cantidad de productos disponibles</span>
        <span class="hljs-attr">page</span>: page,
        <span class="hljs-attr">lastPage</span>: lastPage, <span class="hljs-comment">//el total de páginas en el documento</span>
      }
    }
  }
</div></code></pre>
<hr>
<h2 id="retornar-producto-por-id">Retornar producto por id</h2>
<pre class="hljs"><code><div><span class="hljs-keyword">async</span> findOne(id: number) {
    <span class="hljs-keyword">const</span> product =  <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.product.findFirst({
      <span class="hljs-attr">where</span>:{ id, <span class="hljs-attr">available</span>: <span class="hljs-literal">true</span> }
    });

    <span class="hljs-keyword">if</span> ( !product ) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadRequestException(<span class="hljs-string">`No hay ningún producto con el id <span class="hljs-subst">${id}</span>`</span>);
    }

    <span class="hljs-keyword">return</span> product;

  }
</div></code></pre>
<hr>
<h2 id="actualizar">Actualizar</h2>
<ul>
<li>El dto</li>
<li>Uso PATCH /:id</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-keyword">async</span> update(id: number, <span class="hljs-attr">updateProductDto</span>: UpdateProductDto) {

    <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.findOne(id);
    
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.product.update({
      <span class="hljs-attr">where</span>: { id },
      <span class="hljs-attr">data</span>: updateProductDto,
    });
  }
</div></code></pre>
<hr>
<h2 id="eliminaci%C3%B3n">Eliminación</h2>
<ul>
<li>Por lo general no voy a querer borrar un producto porque no sé que microservicios pueden tener relaciones con ese producto</li>
<li>Esto podría generar una serie de errores en cascada</li>
<li>Hago un borrado lógico. Cambio el avaliable a false</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">async</span> remove(id: number) {

    <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.findOne(id);
    
    <span class="hljs-comment">// return this.product.delete({</span>
    <span class="hljs-comment">//   where: { id }</span>
    <span class="hljs-comment">// });</span>

    <span class="hljs-keyword">const</span> product = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.product.update({
      <span class="hljs-attr">where</span>: { id },
      <span class="hljs-attr">data</span>: {
        <span class="hljs-attr">available</span>: <span class="hljs-literal">false</span>
      }
    });

    <span class="hljs-keyword">return</span> product;


  }
</div></code></pre>
<hr>
<h2 id="transformar-a-microservicio">Transformar a microservicio</h2>
<ul>
<li>Instalo @nestjs/microservices</li>
<li>Para crear el microservicio, en el main creo app con NestFactory</li>
<li>Le mando el AppModule y el objeto de configuración</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { MicroserviceOptions, Transport } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/microservices'</span>;

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bootstrap</span>(<span class="hljs-params"></span>) </span>{

  <span class="hljs-keyword">const</span> logger = <span class="hljs-keyword">new</span> Logger(<span class="hljs-string">'Main'</span>);


<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">await</span> NestFactory.createMicroservice&lt;MicroserviceOptions&gt;(
    
    AppModule,
    {
      <span class="hljs-attr">transport</span>: Transport.TCP, <span class="hljs-comment">//Elijo que tipo de transporte quiero usar</span>
      <span class="hljs-attr">options</span>: {
        <span class="hljs-attr">port</span>: envs.port
      }
    }
  );
}
</div></code></pre>
<ul>
<li>Puedo usar <strong>app.startAllMicroservices()</strong> para inciar todos los microservicios</li>
<li>En este momento esto haría mi aplicación híbrida entre REST y microservicios (<strong>ES COMPATIBLE</strong>)</li>
<li>Pero yo no quiero que esto sea un híbrido por lo que no usaré este comando</li>
<li>Si te fijas en consola ya no aparacen los endpoints GET POST PATCH DELETE que se habían incializado</li>
<li>Ya no estamos escuchando peticiones HTTP en ese puerto (pese a que ahi está el microservicio)</li>
<li>Para comunicarnos tenemos los <strong>eventos</strong> y la <strong>mensajería</strong></li>
<li><em>@MessagePattern</em> es &quot;<strong>te envío la pelota, regrésame la pelota con la información, ya puedo seguir con mi tarea</strong>&quot;</li>
<li><em>@EventPattern</em> es &quot;<strong>yo te mando el evento, y lo que suceda ahí ya es cosa tuya a mi me importa poco, sigo con mi vida</strong>&quot;</li>
<li>En el controlador</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Controller, ParseIntPipe } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { ProductsService } <span class="hljs-keyword">from</span> <span class="hljs-string">'./products.service'</span>;
<span class="hljs-keyword">import</span> { CreateProductDto } <span class="hljs-keyword">from</span> <span class="hljs-string">'./dto/create-product.dto'</span>;
<span class="hljs-keyword">import</span> { UpdateProductDto } <span class="hljs-keyword">from</span> <span class="hljs-string">'./dto/update-product.dto'</span>;
<span class="hljs-keyword">import</span> { PaginationDto } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/common'</span>;
<span class="hljs-keyword">import</span> { MessagePattern, Payload } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/microservices'</span>;

@Controller(<span class="hljs-string">'products'</span>)
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductsController</span> </span>{
  <span class="hljs-keyword">constructor</span>(private readonly productsService: ProductsService) {}

  <span class="hljs-comment">// @Post()</span>
  @MessagePattern({ <span class="hljs-attr">cmd</span>: <span class="hljs-string">'create_product'</span> }) <span class="hljs-comment">//lo que hay en cmd es el string que me servirá para comunicar los microservicios</span>
  create(@Payload() createProductDto: CreateProductDto) { <span class="hljs-comment">//en el Payload está la información</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.productsService.create(createProductDto);
  }

  <span class="hljs-comment">// @Get()</span>
  @MessagePattern({ <span class="hljs-attr">cmd</span>: <span class="hljs-string">'find_all_products'</span> })
  findAll(@Payload() paginationDto: PaginationDto) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.productsService.findAll(paginationDto);
  }

  <span class="hljs-comment">// @Get(':id')</span>
  @MessagePattern({ <span class="hljs-attr">cmd</span>: <span class="hljs-string">'find_one_product'</span> })
  findOne(@Payload(<span class="hljs-string">'id'</span>, ParseIntPipe) id: number) {
    <span class="hljs-comment">// { id: 1</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.productsService.findOne(id);
  }

  <span class="hljs-comment">// @Patch(':id')</span>
  @MessagePattern({ <span class="hljs-attr">cmd</span>: <span class="hljs-string">'update_product'</span> })
  update(
    <span class="hljs-comment">// @Param('id', ParseIntPipe) id: number,</span>
    <span class="hljs-comment">// @Body() updateProductDto: UpdateProductDto,</span>
    @Payload() updateProductDto: UpdateProductDto,
  ) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.productsService.update(updateProductDto.id, updateProductDto);
  }

  <span class="hljs-comment">// @Delete(':id')</span>
  @MessagePattern({ <span class="hljs-attr">cmd</span>: <span class="hljs-string">'delete_product'</span> })
  remove(@Payload(<span class="hljs-string">'id'</span>, ParseIntPipe) id: number) { <span class="hljs-comment">//puedo usar el ParseIntPipe con el id del payload!!</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.productsService.remove(id);
  }
}
</div></code></pre>
<ul>
<li>Para la actualización ya no tengo <strong>@Params</strong>, viene todo en el <strong>@Payload</strong></li>
<li>Modifico esto, hago un dto para el update</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { PartialType } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/mapped-types'</span>;
<span class="hljs-keyword">import</span> { CreateProductDto } <span class="hljs-keyword">from</span> <span class="hljs-string">'./create-product.dto'</span>;
<span class="hljs-keyword">import</span> { IsNumber, IsPositive } <span class="hljs-keyword">from</span> <span class="hljs-string">'class-validator'</span>;

                                      <span class="hljs-comment">//PartialType hace todas las propiedades del dto padre opcionales</span>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UpdateProductDto</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PartialType</span>(<span class="hljs-title">CreateProductDto</span>) </span>{

  @IsNumber()
  @IsPositive()
  <span class="hljs-attr">id</span>: number;

}
</div></code></pre>
<ul>
<li>Cambio el método en el servicio</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">async</span> update(id: number, <span class="hljs-attr">updateProductDto</span>: UpdateProductDto) {

    <span class="hljs-comment">//ya tengo el id en id:updateProduct.id desde el controlador en la variable id</span>
    <span class="hljs-comment">//extraigo la data y le quito el id pq no me interesa</span>
    <span class="hljs-keyword">const</span> { <span class="hljs-attr">id</span>: __, ...data } = updateProductDto; <span class="hljs-comment">//el id lo renombro a guión bajo pq no me interesa</span>


    <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.findOne(id);
    
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.product.update({
      <span class="hljs-attr">where</span>: { id },
      <span class="hljs-attr">data</span>: data,
    });
  }
</div></code></pre>
<ul>
<li>Cuando el microservicio A quiera comunicarse con el microservicio B va a tener que usar el mismo objeto <strong>{cmd:'lo que sea'}</strong></li>
<li>Ahora uso <strong>@Payload</strong> para la información</li>
<li><strong>Podría mantener el @POST o el @GET si fuera un híbrido</strong>, iniciando desde el main con <strong>.startAllMicroservices</strong></li>
<li>Esto será útil con la autenticación, ya que puede ser una API propia o un microservicio</li>
<li>No tengo porqué mandar el mensaje como un cmd:&quot;string&quot;, puedo colocar solo un string, pero el standard es el objeto con cmd
<ul>
<li><strong>Ya está el microservicio implementado. Cómo lo vamos a probar?</strong></li>
<li><strong>Lo vamos a probar mediante un GATEWAY, va a ser el punto intermedio. Crearemos un API REST donde mis clientes se van a conectar y este GATEWAY se va a encargar de comunicarse mediante los microservicios usando TCP</strong></li>
</ul>
</li>
</ul>
<hr>
<h2 id="github-organization">Github Organization</h2>
<ul>
<li>Podemos crear una organización para agrupar todos los microservicios</li>
<li>En Github Your Organizations /New Organization / Free Organization</li>
<li>No invito a nadie (skip this step)</li>
<li>Creo un nuevo repo</li>
</ul>
<hr>
<h1 id="02--nest-microservices---client-gateway">02- NEST MICROSERVICES - CLIENT-GATEWAY</h1>
<ul>
<li>Instalo dotenv joi @nestjs/microservices</li>
<li>Tenemos que crear algo muy parecido al REST API de productos</li>
<li>Es el cliente quien se va aq conectar al microservicio de productos</li>
<li>Configuro las variables de entorno (uso el snippet)</li>
<li>config/envs.ts</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> <span class="hljs-string">'dotenv/config'</span>;

<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> joi <span class="hljs-keyword">from</span> <span class="hljs-string">'joi'</span>;

<span class="hljs-comment">//hago la interfaz</span>
interface EnvVars {
  <span class="hljs-attr">PORT</span>: number;
  PRODUCTS_MICROSERVICE_HOST: string;
  PRODUCTS_MICROSERVICE_PORT: number;
}

<span class="hljs-comment">//creo el Schema</span>
<span class="hljs-keyword">const</span> envsSchema = joi.object({
  <span class="hljs-attr">PORT</span>: joi.number().required(),
  <span class="hljs-attr">PRODUCTS_MICROSERVICE_HOST</span>: joi.string().required(),
  <span class="hljs-attr">PRODUCTS_MICROSERVICE_PORT</span>: joi.number().required(),

})
.unknown(<span class="hljs-literal">true</span>); <span class="hljs-comment">//para el resto de variables en process.env</span>

<span class="hljs-comment">//desestructuro el error y value</span>
<span class="hljs-keyword">const</span> { error, value } = envsSchema.validate( process.env );


<span class="hljs-comment">//si hay algún error lo lanzo</span>
<span class="hljs-keyword">if</span> ( error ) {
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Config validation error: <span class="hljs-subst">${ error.message }</span>`</span>);
}

<span class="hljs-comment">//guardo el valor en una variable que cumple con la interfaz</span>
<span class="hljs-keyword">const</span> envVars:EnvVars = value;


<span class="hljs-comment">//exporto las variables en un objeto</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> envs = {
  <span class="hljs-attr">port</span>: envVars.PORT,
  <span class="hljs-attr">productsMicroserviceHost</span>: envVars.PRODUCTS_MICROSERVICE_HOST,
  <span class="hljs-attr">productsMicroservicePort</span>: envVars.PRODUCTS_MICROSERVICE_PORT,
};
</div></code></pre>
<ul>
<li>.env</li>
</ul>
<pre class="hljs"><code><div>PORT=3000


PRODUCTS_MICROSERVICE_HOST=localhost
PRODUCTS_MICROSERVICE_PORT=3001
</div></code></pre>
<ul>
<li>Creemos las rutas</li>
</ul>
<blockquote>
<p>nest g res products</p>
</blockquote>
<ul>
<li>El cliente <strong>SI ES UN RESTFULL API</strong></li>
<li>No voy a necesitar el servicio</li>
<li>Pongo a correr el microservicio de products</li>
<li>Creo la conexión en products.module del CLIENTE_GATEWAY, registro el microservicio en imports</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Module } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { ProductsController } <span class="hljs-keyword">from</span> <span class="hljs-string">'./products.controller'</span>;
<span class="hljs-keyword">import</span> { ClientsModule, Transport } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/microservices'</span>;
<span class="hljs-keyword">import</span> { PRODUCT_SERVICE, envs } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/config'</span>;

@Module({
  <span class="hljs-attr">controllers</span>: [ProductsController],
  <span class="hljs-attr">providers</span>: [],
  <span class="hljs-attr">imports</span>: [
    ClientsModule.register([
      
      { 
        <span class="hljs-attr">name</span>: PRODUCT_SERVICE, <span class="hljs-comment">//variable en /config/services (injection token) </span>
        <span class="hljs-attr">transport</span>: Transport.TCP, <span class="hljs-comment">//uso el mismo canal de comunicación que usa el microservicio de productos</span>
        <span class="hljs-attr">options</span>: {
          <span class="hljs-attr">host</span>: envs.productsMicroserviceHost, <span class="hljs-comment">//localhost</span>
          <span class="hljs-attr">port</span>: envs.productsMicroservicePort <span class="hljs-comment">//3001, el de products-microservice</span>
        }
      },

    ]),
  ]
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductsModule</span> </span>{}
</div></code></pre>
<ul>
<li>Fijarse que .register abre un arreglo en el que puedes registrar todos los microservicios que necesites</li>
<li>En app.module (del client-gateway) solo tengo ProductsModule</li>
<li>Creo el fichero /config/services.ts donde coloco la variable (o injection token) que va a identificar a el transport que voy a colocar. Viene a ser la definición de mi microservicio</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> PRODUCT_SERVICE = <span class="hljs-string">'PRODUCT_SERVICE'</span>;
</div></code></pre>
<ul>
<li>Es lo que vamos a necesitar para inyectar el (micro)servicio en los controladores</li>
<li>Lo guardamos en una variable para no tener problemas de errores con el string</li>
<li>Creo un archivo de barril en config/index.ts</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">'./envs'</span>;
<span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">'./services'</span>;
</div></code></pre>
<hr>
<h2 id="obtener-todos-los-productos">Obtener todos los productos</h2>
<ul>
<li>Si estuviera trabajando las variables de entorno con ConfigModule tendria que usar r .registerAsync() en products.module del gateway, inyectar el ConfigModule...</li>
<li>Para conectar con findProducts inyectamos el microservicio de products en el controlador</li>
<li>client-gateway-products.controller</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { ClientProxy} <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/microservices'</span>;

@Controller(<span class="hljs-string">'products'</span>)
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductsController</span> </span>{
  <span class="hljs-keyword">constructor</span>(
    @Inject(PRODUCT_SERVICE) private readonly productsClient: ClientProxy,
  ) {}
}
</div></code></pre>
<ul>
<li>En el controlador findAllProducts llamo al microservicio</li>
<li>Si espero una respuesta uso <strong>.send</strong></li>
<li>Si no espero una respuesta uso <strong>.emit</strong></li>
<li>Le paso exactamente lo mismo que puse entre paréntesis del @MessagePattern</li>
<li>En este caso de segundo argumento le paso un objeto vacío</li>
<li>Es porque está esperando el payload, que en este caso es el paginationDto</li>
</ul>
<pre class="hljs"><code><div>@Get()
  findAllProducts() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.productsClient.send(
      { <span class="hljs-attr">cmd</span>: <span class="hljs-string">'find_all_products'</span> }, {}
    );
  }
</div></code></pre>
<ul>
<li>En products-micro-service.controller</li>
</ul>
<pre class="hljs"><code><div>@MessagePattern({ <span class="hljs-attr">cmd</span>: <span class="hljs-string">'find_all_products'</span> })
  findAll(@Payload() paginationDto: PaginationDto) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.productsService.findAll(paginationDto);
  }
</div></code></pre>
<ul>
<li>Los valores del paginationDTo son opcionales</li>
<li>Para incluir los query parameters que introduzco en la url &quot;products?page=2&amp;limit=10&quot; uso <strong>@Query</strong></li>
<li>client-gateway.products.controller</li>
</ul>
<pre class="hljs"><code><div>@Get()
findAllProducts(@Query() paginationDto: PaginationDto) {
<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.productsClient.send(
    { <span class="hljs-attr">cmd</span>: <span class="hljs-string">'find_all_products'</span> },
    paginationDto,
);
}
</div></code></pre>
<ul>
<li>Resumiendo:
<ul>
<li>En el products.module del cliente registro el microservicio con <strong>ClientsModule.register</strong> que abre un arreglo</li>
<li>Le paso el <strong>token de inyección</strong> que usaré en el controlador para inyectar el microservicio (no es más que una variable que me sirve para identificar el microservicio que estoy registrando en products.module del cliente-gateway), el mismo tipo de transporte que usa dicho microservicio, y dentro de options le paso el puerto del microservicio y el host (en este caso localhost)</li>
<li>Inyecto el microservicio en el controlador del cliente usando <strong>@Inject(token de inyección)</strong> y el tipado es client: <strong>ClientProxy</strong></li>
<li>Para comunicarme con el controlador de products y poder usarlo, usaré <strong>.send</strong> si espero una respuesta, y cómo argumento primero el objeto literal que hay en <strong>@MessagePattern</strong> y lo que sea que me pide (<strong>Payload</strong>)</li>
</ul>
</li>
</ul>
<hr>
<h2 id="manejo-de-excepciones">Manejo de excepciones</h2>
<ul>
<li>Para buscar por id desde el controlador del cliente-gateway debo pasarle el mismo objeto que en el @MessagePattern del servicio de productsy el @Payload, en este caso el id</li>
<li>Uso con <strong>productsClient: ClientProxy</strong> al que le he inyectado el token de PRODUCT_SERVICE, con <strong>.send</strong> porque espero respuesta</li>
<li>Este .send es un <strong>Observable</strong> (devuelve un Observable). No es más que <strong>un flujo de información</strong></li>
<li>Para escuchar los Observables necesito el <strong>.subscribe()</strong> y mandarle la respuesta y retornarla</li>
</ul>
<pre class="hljs"><code><div>.subscribe(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>{
  <span class="hljs-comment">//return res</span>
})
</div></code></pre>
<ul>
<li>Esa como se trabajan comunmente los Observables</li>
<li>Estoy lanzando un NotFoundException desde el servicio de products.microservice, pero los errores son atrapados en los RpcException cuando usamos .send y microservicios</li>
<li>Vamos a crear un ExceptionFilter para atrapar todos los Rpc</li>
<li>Primero solucionémoslo de manera empírica</li>
<li>Lo meto en un try catch y uso el .firstValueFrom de rxjs que me permite trabajar como una promesa el Observable</li>
<li>Le estoy diciendo &quot;espera el primer valor que este Observable va a emitir&quot;</li>
<li>Puedo usar .pipe con catchError o puedo capturarlo en el catch
-client-gateway.products.controller</li>
</ul>
<pre class="hljs"><code><div>@Get(<span class="hljs-string">':id'</span>)
  <span class="hljs-keyword">async</span> findOne(@Param(<span class="hljs-string">'id'</span>) id: string) {
    
    <span class="hljs-keyword">try</span>{      
      <span class="hljs-keyword">const</span> product= <span class="hljs-keyword">await</span> firstValuefrom(
        <span class="hljs-keyword">this</span>.productsClient.send({ <span class="hljs-attr">cmd</span>: <span class="hljs-string">'find_one_product'</span> }, { id })
      )

      <span class="hljs-keyword">return</span> product

    }<span class="hljs-keyword">catch</span>(error){
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadRequestException(error)
    }
    
    
  }

</div></code></pre>
<ul>
<li>Pero así no estoy atrapando la RpcException</li>
</ul>
<hr>
<h2 id="exceptionfilter">ExceptionFilter</h2>
<ul>
<li>Las excepciones van a estar continuamente manejadas como RpcException, a veces puede que manden un string y no un objeto</li>
<li>Vamos a hacer que las excepciones siempre sean manejadas como objetos y no solo como strings</li>
<li>Uso el decorador <strong>@Catch()</strong> y le paso el RpcException de @nestjs/microservices</li>
<li>Implemento la clase <strong>ExceptionFilter</strong></li>
<li>En el metodo <strong>catch</strong> le paso la <strong>RpcException</strong> y el <strong>host: ArgumentsHost</strong></li>
<li>Creo el <strong>context</strong> usando el <strong>host</strong> y <strong>.switchToHttp()</strong></li>
<li>Obtengo la <strong>response</strong> (la respuesta) con el context <strong>.getResponse()</strong></li>
<li><strong>Guardo el error</strong> usando la RpcException que pasé como parámetro al catch con <strong>.getError()</strong></li>
<li>Si el error es un objeto y contiene status y message <strong>me aseguro de que el status es un número</strong> y si no lo casteo</li>
<li><strong>Retorno la response que obtuve del context</strong> con <strong>.status</strong> y <strong>envío el error con .json</strong></li>
<li>Si no pasa las validaciones <strong>genero yo la respuesta como un objeto</strong> pasándole <strong>status y messsage</strong></li>
<li><strong>El global exceptionFilter no está disponible en aplicaciones híbridas</strong></li>
<li>El exceptionFilter esta <strong>fuera del Exception zone</strong></li>
<li>/common/exceptions/roc-custom-exception.filter.ts</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Catch, ArgumentsHost, ExceptionFilter } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;

<span class="hljs-keyword">import</span> { RpcException } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/microservices'</span>;

@Catch(RpcException)
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcCustomExceptionFilter</span> <span class="hljs-title">implements</span> <span class="hljs-title">ExceptionFilter</span> </span>{
  <span class="hljs-keyword">catch</span>(exception: RpcException, <span class="hljs-attr">host</span>: ArgumentsHost) {
    <span class="hljs-keyword">const</span> ctx = host.switchToHttp();
    <span class="hljs-keyword">const</span> response = ctx.getResponse();

    <span class="hljs-keyword">const</span> rpcError = exception.getError();

    <span class="hljs-keyword">if</span> (
      <span class="hljs-keyword">typeof</span> rpcError === <span class="hljs-string">'object'</span> &amp;&amp;
      <span class="hljs-string">'status'</span> <span class="hljs-keyword">in</span> rpcError &amp;&amp;
      <span class="hljs-string">'message'</span> <span class="hljs-keyword">in</span> rpcError
    ) {
      <span class="hljs-keyword">const</span> status = <span class="hljs-built_in">isNaN</span>(+rpcError.status) ? <span class="hljs-number">400</span> :+rpcError.status;
      <span class="hljs-keyword">return</span> response.status(status).json(rpcError);
    }

    response.status(<span class="hljs-number">400</span>).json({
      <span class="hljs-attr">status</span>: <span class="hljs-number">400</span>,
      <span class="hljs-attr">message</span>: rpcError,
    });
  }
}
</div></code></pre>
<ul>
<li>Lo coloco en el main par aplicarlo</li>
</ul>
<pre class="hljs"><code><div>app.useGlobalFilters(<span class="hljs-keyword">new</span> RpcCustomExceptionFilter())
</div></code></pre>
<ul>
<li>En el controlador del cliente estaba atrapando la excepción con un try catch y mandando un BadRequest</li>
<li>Si hago un console.log del error no tengo una instancia de RpcException si no un objeto con status y message</li>
<li>Debo enviar el RpcException para poder mandarlo en la respuesta</li>
<li>client-gateway.products.controller</li>
</ul>
<pre class="hljs"><code><div>@Get(<span class="hljs-string">':id'</span>)
  <span class="hljs-keyword">async</span> findOne(@Param(<span class="hljs-string">'id'</span>) id: string) {
    
    <span class="hljs-keyword">try</span>{      
      <span class="hljs-keyword">const</span> product= <span class="hljs-keyword">await</span> firstValuefrom(
        <span class="hljs-keyword">this</span>.productsClient.send({ <span class="hljs-attr">cmd</span>: <span class="hljs-string">'find_one_product'</span> }, { id })
      )

      <span class="hljs-keyword">return</span> product

    }<span class="hljs-keyword">catch</span>(error){
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(error)
    } 
  }
</div></code></pre>
<ul>
<li>En product-microservice.service lanzo el RpcException con el message y el status</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">async</span> findOne(id: number) {
  <span class="hljs-keyword">const</span> product =  <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.product.findFirst({
    <span class="hljs-attr">where</span>:{ id, <span class="hljs-attr">available</span>: <span class="hljs-literal">true</span> }
  });

  <span class="hljs-keyword">if</span> ( !product ) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException({ 
      <span class="hljs-attr">message</span>: <span class="hljs-string">`Product with id #<span class="hljs-subst">${ id }</span> not found`</span>,
      <span class="hljs-attr">status</span>: HttpStatus.BAD_REQUEST <span class="hljs-comment">//HttpStatus de @nestjs/common</span>
    });
  }

  <span class="hljs-keyword">return</span> product;

}
</div></code></pre>
<ul>
<li>En el cliente puedo usar .pipe con catchError para atrapar la RpcException que ha pasado por el ExceptionFilter</li>
<li>.pipe viene en los observables, catchError viene de rxjs</li>
<li>client-gateway.products.controller</li>
</ul>
<pre class="hljs"><code><div>@Get(<span class="hljs-string">':id'</span>)
<span class="hljs-keyword">async</span> findOne(@Param(<span class="hljs-string">'id'</span>) id: string) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.productsClient.send({ <span class="hljs-attr">cmd</span>: <span class="hljs-string">'find_one_product'</span> }, { id }).pipe(
    catchError(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(err);
    }),
  );
}
</div></code></pre>
<ul>
<li>Se puede trabajar como Observable con .pipe o como promesa con try catch</li>
</ul>
<hr>
<h2 id="implementar-m%C3%A9todos-faltantes">Implementar métodos faltantes</h2>
<ul>
<li>Creación, borrado y actualizacion en el client-gateway.products.controller</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> {
  BadRequestException,
  Body,
  Controller,
  Delete,
  Get,
  Inject,
  Param,
  ParseIntPipe,
  Patch,
  Post,
  Query,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { ClientProxy, RpcException } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/microservices'</span>;
<span class="hljs-keyword">import</span> { catchError, firstValueFrom } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;
<span class="hljs-keyword">import</span> { PaginationDto } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/common'</span>;
<span class="hljs-keyword">import</span> { PRODUCT_SERVICE } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/config'</span>;
<span class="hljs-keyword">import</span> { CreateProductDto } <span class="hljs-keyword">from</span> <span class="hljs-string">'./dto/create-product.dto'</span>;
<span class="hljs-keyword">import</span> { UpdateProductDto } <span class="hljs-keyword">from</span> <span class="hljs-string">'./dto/update-product.dto'</span>;

@Controller(<span class="hljs-string">'products'</span>)
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductsController</span> </span>{
  <span class="hljs-keyword">constructor</span>(
    @Inject(PRODUCT_SERVICE) private readonly productsClient: ClientProxy,
  ) {}

  @Post()
  createProduct(@Body() createProductDto: CreateProductDto) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.productsClient.send(
      { <span class="hljs-attr">cmd</span>: <span class="hljs-string">'create_product'</span> },
      createProductDto,
    );
  }

  @Get()
  findAllProducts(@Query() paginationDto: PaginationDto) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.productsClient.send(
      { <span class="hljs-attr">cmd</span>: <span class="hljs-string">'find_all_products'</span> },
      paginationDto,
    );
  }

  @Get(<span class="hljs-string">':id'</span>)
  <span class="hljs-keyword">async</span> findOne(@Param(<span class="hljs-string">'id'</span>) id: string) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.productsClient.send({ <span class="hljs-attr">cmd</span>: <span class="hljs-string">'find_one_product'</span> }, { id }).pipe(
      catchError(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(err);
      }),
    );

    <span class="hljs-comment">// try {</span>

    <span class="hljs-comment">//   const product = await firstValueFrom(</span>
    <span class="hljs-comment">//     this.productsClient.send({ cmd: 'find_one_product' },{ id })</span>
    <span class="hljs-comment">//   );</span>
    <span class="hljs-comment">//   return product;</span>

    <span class="hljs-comment">// } catch (error) {</span>
    <span class="hljs-comment">//   throw new RpcException(error);</span>
    <span class="hljs-comment">// }</span>
  }

  @Delete(<span class="hljs-string">':id'</span>)
  deleteProduct(@Param(<span class="hljs-string">'id'</span>) id: string) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.productsClient.send({ <span class="hljs-attr">cmd</span>: <span class="hljs-string">'delete_product'</span> }, { id }).pipe(
      catchError(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(err);
      }),
    );
  }

  @Patch(<span class="hljs-string">':id'</span>)
  patchProduct(
    @Param(<span class="hljs-string">'id'</span>, ParseIntPipe) id: number, <span class="hljs-comment">//casteo el id</span>
    @Body() updateProductDto: UpdateProductDto,
  ) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.productsClient
      .send(
        { <span class="hljs-attr">cmd</span>: <span class="hljs-string">'update_product'</span> },
        {
          id,
          ...updateProductDto,
        },
      )
      .pipe(
        catchError(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(err);
        }),
      );
  }
}
</div></code></pre>
<ul>
<li>Paso el servicio de products.microservices</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { HttpStatus, Injectable, Logger, OnModuleInit } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { CreateProductDto } <span class="hljs-keyword">from</span> <span class="hljs-string">'./dto/create-product.dto'</span>;
<span class="hljs-keyword">import</span> { UpdateProductDto } <span class="hljs-keyword">from</span> <span class="hljs-string">'./dto/update-product.dto'</span>;
<span class="hljs-keyword">import</span> { RpcException } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/microservices'</span>;
<span class="hljs-keyword">import</span> { PrismaClient } <span class="hljs-keyword">from</span> <span class="hljs-string">'@prisma/client'</span>;

<span class="hljs-keyword">import</span> { PaginationDto } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/common'</span>;

@Injectable()
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductsService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PrismaClient</span> <span class="hljs-title">implements</span> <span class="hljs-title">OnModuleInit</span> </span>{

  private readonly logger = <span class="hljs-keyword">new</span> Logger(<span class="hljs-string">'ProductsService'</span>);

  onModuleInit() {
    <span class="hljs-keyword">this</span>.$connect();
    <span class="hljs-keyword">this</span>.logger.log(<span class="hljs-string">'Database connected'</span>);
  }

  create(createProductDto: CreateProductDto) {
    
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.product.create({
      <span class="hljs-attr">data</span>: createProductDto
    });
    
  }

  <span class="hljs-keyword">async</span> findAll( paginationDto: PaginationDto ) {

    <span class="hljs-keyword">const</span> { page, limit } = paginationDto;

    <span class="hljs-keyword">const</span> totalPages = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.product.count({ <span class="hljs-attr">where</span>: { <span class="hljs-attr">available</span>: <span class="hljs-literal">true</span> } });
    <span class="hljs-keyword">const</span> lastPage = <span class="hljs-built_in">Math</span>.ceil( totalPages / limit );

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">data</span>: <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.product.findMany({
        <span class="hljs-attr">skip</span>: ( page - <span class="hljs-number">1</span> ) * limit,
        <span class="hljs-attr">take</span>: limit,
        <span class="hljs-attr">where</span>: {
          <span class="hljs-attr">available</span>: <span class="hljs-literal">true</span>
        }
      }),
      <span class="hljs-attr">meta</span>: {
        <span class="hljs-attr">total</span>: totalPages,
        <span class="hljs-attr">page</span>: page,
        <span class="hljs-attr">lastPage</span>: lastPage,
      }
    }
  }

  <span class="hljs-keyword">async</span> findOne(id: number) {
    <span class="hljs-keyword">const</span> product =  <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.product.findFirst({
      <span class="hljs-attr">where</span>:{ id, <span class="hljs-attr">available</span>: <span class="hljs-literal">true</span> }
    });

    <span class="hljs-keyword">if</span> ( !product ) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException({ 
        <span class="hljs-attr">message</span>: <span class="hljs-string">`Product with id #<span class="hljs-subst">${ id }</span> not found`</span>,
        <span class="hljs-attr">status</span>: HttpStatus.BAD_REQUEST
      });
    }

    <span class="hljs-keyword">return</span> product;

  }

  <span class="hljs-keyword">async</span> update(id: number, <span class="hljs-attr">updateProductDto</span>: UpdateProductDto) {

    <span class="hljs-keyword">const</span> { <span class="hljs-attr">id</span>: __, ...data } = updateProductDto;


    <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.findOne(id);
    
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.product.update({
      <span class="hljs-attr">where</span>: { id },
      <span class="hljs-attr">data</span>: data,
    });


  }

  <span class="hljs-keyword">async</span> remove(id: number) {

    <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.findOne(id);
    
    <span class="hljs-comment">// return this.product.delete({</span>
    <span class="hljs-comment">//   where: { id }</span>
    <span class="hljs-comment">// });</span>

    <span class="hljs-keyword">const</span> product = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.product.update({
      <span class="hljs-attr">where</span>: { id },
      <span class="hljs-attr">data</span>: {
        <span class="hljs-attr">available</span>: <span class="hljs-literal">false</span>
      }
    });

    <span class="hljs-keyword">return</span> product;


  }
}
</div></code></pre>
<ul>
<li>Paso también el products-microservice.controller</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Controller, ParseIntPipe } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { ProductsService } <span class="hljs-keyword">from</span> <span class="hljs-string">'./products.service'</span>;
<span class="hljs-keyword">import</span> { CreateProductDto } <span class="hljs-keyword">from</span> <span class="hljs-string">'./dto/create-product.dto'</span>;
<span class="hljs-keyword">import</span> { UpdateProductDto } <span class="hljs-keyword">from</span> <span class="hljs-string">'./dto/update-product.dto'</span>;
<span class="hljs-keyword">import</span> { PaginationDto } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/common'</span>;
<span class="hljs-keyword">import</span> { MessagePattern, Payload } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/microservices'</span>;

@Controller(<span class="hljs-string">'products'</span>)
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductsController</span> </span>{
  <span class="hljs-keyword">constructor</span>(private readonly productsService: ProductsService) {}

  <span class="hljs-comment">// @Post()</span>
  @MessagePattern({ <span class="hljs-attr">cmd</span>: <span class="hljs-string">'create_product'</span> })
  create(@Payload() createProductDto: CreateProductDto) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.productsService.create(createProductDto);
  }

  <span class="hljs-comment">// @Get()</span>
  @MessagePattern({ <span class="hljs-attr">cmd</span>: <span class="hljs-string">'find_all_products'</span> })
  findAll(@Payload() paginationDto: PaginationDto) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.productsService.findAll(paginationDto);
  }

  <span class="hljs-comment">// @Get(':id')</span>
  @MessagePattern({ <span class="hljs-attr">cmd</span>: <span class="hljs-string">'find_one_product'</span> })
  findOne(@Payload(<span class="hljs-string">'id'</span>, ParseIntPipe) id: number) {
    <span class="hljs-comment">// { id: 1</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.productsService.findOne(id);
  }

  <span class="hljs-comment">// @Patch(':id')</span>
  @MessagePattern({ <span class="hljs-attr">cmd</span>: <span class="hljs-string">'update_product'</span> })
  update(
    <span class="hljs-comment">// @Param('id', ParseIntPipe) id: number,</span>
    <span class="hljs-comment">// @Body() updateProductDto: UpdateProductDto,</span>
    @Payload() updateProductDto: UpdateProductDto,
  ) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.productsService.update(updateProductDto.id, updateProductDto);
  }

  <span class="hljs-comment">// @Delete(':id')</span>
  @MessagePattern({ <span class="hljs-attr">cmd</span>: <span class="hljs-string">'delete_product'</span> })
  remove(@Payload(<span class="hljs-string">'id'</span>, ParseIntPipe) id: number) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.productsService.remove(id);
  }
}
</div></code></pre>
<ul>
<li>Resumen de la comunicación:
<ul>
<li>En el products-microservice.controller creo el objeto de @MessagePattern que me servirá para comunicarme con el cliente</li>
<li>Le paso al servicio los parámetros que necesita que vendrán del cliente</li>
<li>En el cliente inyectando el ClientProxy en el controlador, uso .send y le paso en un objeto el objeto (literal) del MessagePattern
<ul>
<li>Y en otro objeto el Payload del products.microservice.controller (no disponemos de @Params, @Body, etc) con lo que necesita</li>
</ul>
</li>
<li>Cuando trabajo con .send trabajo con Observables, para manejar los errores debo usar RpcException</li>
<li>Puedo trabajar los Observables como promesas con try catch y async await</li>
</ul>
</li>
<li>Evidentemente hay más pasos con la conexión, el registro del cliente, etc</li>
<li>Pero la comunicación viene a ser esa</li>
</ul>
<hr>
<h1 id="03--nest-microservicios---orders">03- NEST MICROSERVICIOS - ORDERS</h1>
<ul>
<li>Trabajaremos con PostgreSQL</li>
<li>Las órdenes solo será el header de las órdenes</li>
<li>En otro microservicio con Mongo tendremos el detalle</li>
<li>Lo quiero manetener independiente para que puedan escalar sin manetener una relación entre si</li>
<li>Creo un nuevo proyecto de Nest con <strong>nest new</strong></li>
<li>Levanto el gateway (da error porque no tengo Productos levantado)</li>
<li>Configuro las variables de entorno de Orders, instalo <strong>joi y dotenv</strong></li>
<li>/config/envs.ts</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> <span class="hljs-string">'dotenv/config'</span>;

<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> joi <span class="hljs-keyword">from</span> <span class="hljs-string">'joi'</span>;

interface EnvVars {
  <span class="hljs-attr">PORT</span>: number;
}

<span class="hljs-keyword">const</span> envsSchema = joi.object({
  <span class="hljs-attr">PORT</span>: joi.number().required(),
})
.unknown(<span class="hljs-literal">true</span>);

<span class="hljs-keyword">const</span> { error, value } = envsSchema.validate( process.env );


<span class="hljs-keyword">if</span> ( error ) {
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Config validation error: <span class="hljs-subst">${ error.message }</span>`</span>);
}

<span class="hljs-keyword">const</span> envVars:EnvVars = value;


<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> envs = {
  <span class="hljs-attr">port</span>: envVars.PORT,
};
</div></code></pre>
<ul>
<li>Coloco el puerto en el main para que corra en el 3002 y no de error</li>
<li>Creo el logger en el main con <strong>new Logger</strong></li>
</ul>
<hr>
<h2 id="configuraci%C3%B3n">Configuración</h2>
<ul>
<li>Necesito crear los canales de comunicación para poder crear4 una orden similar a un CRUD pero con el MessagePattern y falta la instalación de los microservicios</li>
<li>Instalo @nestjs/microservices</li>
<li>Configuro el main con .createMicroservice al que le paso el AppModule y el objeto de configuración del microservicio con el tipo de transporte y el puerto en el objeto options</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Logger, ValidationPipe } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { NestFactory } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/core'</span>;
<span class="hljs-keyword">import</span> { AppModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.module'</span>;
<span class="hljs-keyword">import</span> { envs } <span class="hljs-keyword">from</span> <span class="hljs-string">'./config'</span>;
<span class="hljs-keyword">import</span> { MicroserviceOptions, Transport } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/microservices'</span>;

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bootstrap</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> logger = <span class="hljs-keyword">new</span> Logger(<span class="hljs-string">'OrdersMS-Main'</span>);

  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">await</span> NestFactory.createMicroservice&lt;MicroserviceOptions&gt;(
    AppModule,
    {
      <span class="hljs-attr">transport</span>: Transport.TCP,
      <span class="hljs-attr">options</span>: {
        <span class="hljs-attr">port</span>: envs.port,
      },
    },
  );

  app.useGlobalPipes(
    <span class="hljs-keyword">new</span> ValidationPipe({
      <span class="hljs-attr">whitelist</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">forbidNonWhitelisted</span>: <span class="hljs-literal">true</span>,
    }),
  );

  <span class="hljs-keyword">await</span> app.listen();
  logger.log(<span class="hljs-string">`Microservice running on port <span class="hljs-subst">${envs.port}</span>`</span>);
}
bootstrap();
</div></code></pre>
<ul>
<li>Usamos el <strong>CLI</strong> con <strong>nest g res orders</strong>
<ul>
<li>En lugar de crear un CRUD API REST, elegimos <strong>Microservices (non-HTTP)</strong></li>
<li>Creo los endpoints (le digo que si)</li>
<li>La entity no la voy a ocupar</li>
<li>En lugar de usar @Get, @Post usará @MessagePattern</li>
<li>Los de actualizar y borrar no los necesito</li>
</ul>
</li>
<li>De forma automática coloco aun string en el MessagePattern
<ul>
<li>Aunque usamos un objeto anteriormente como {cmd: 'mensaje'} en orders usaremos un string</li>
<li>De todas maneras trata de estandarizar los MessagePattern y enviar siempre el mismo formato</li>
</ul>
</li>
<li>Evidentemente quiero llegar a orders desde el cliente-gateway</li>
</ul>
<hr>
<h2 id="conectar-gateway-con-orders">Conectar Gateway con Orders</h2>
<ul>
<li>Para conectar orders.microservice con el cliente-gateway el microservicio tiene que estar levantado</li>
<li><strong>En el cliente</strong> genero un RESTFUL API con nest g res orders
<ul>
<li>La entity no la voy a ocupar</li>
<li>El servicio tampoco (lo borro del controlador y del módulo)</li>
</ul>
</li>
<li>En el ApppModule del cliente-gateway ahora tengo (en imports) a ProductsModule y OrdersModule</li>
<li>Los endpoints de actualizar y borrar no los necesito</li>
<li>Seguimos en el cliente-gateway, en /config/services.ts declaro el token de inyección para identificar el microservicio</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> PRODUCT_SERVICE = <span class="hljs-string">'PRODUCT_SERVICE'</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> ORDER_SERVICE = <span class="hljs-string">'ORDER_SERVICE'</span>;
</div></code></pre>
<ul>
<li>Registro el microservicio en el módulo de la REST API de Orders del cliente-gateway</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Module } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { OrdersController } <span class="hljs-keyword">from</span> <span class="hljs-string">'./orders.controller'</span>;
<span class="hljs-keyword">import</span> { ClientsModule, Transport } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/microservices'</span>;
<span class="hljs-keyword">import</span> { ORDER_SERVICE, envs } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/config'</span>;

@Module({
  <span class="hljs-attr">controllers</span>: [OrdersController],
  <span class="hljs-attr">imports</span>: [
    ClientsModule.register([
      
      { 
        <span class="hljs-attr">name</span>: ORDER_SERVICE, 
        <span class="hljs-attr">transport</span>: Transport.TCP,
        <span class="hljs-attr">options</span>: {
          <span class="hljs-attr">host</span>: envs.ordersMicroserviceHost,
          <span class="hljs-attr">port</span>: envs.ordersMicroservicePort
        }
      },

    ]),
  ]
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrdersModule</span> </span>{}
</div></code></pre>
<ul>
<li>Por supuesto añado las variables de entrono a .env (y .env.template) y a .envs</li>
<li>Recuerda que el puerto tiene que ser un número</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> <span class="hljs-string">'dotenv/config'</span>;

<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> joi <span class="hljs-keyword">from</span> <span class="hljs-string">'joi'</span>;

interface EnvVars {
  <span class="hljs-attr">PORT</span>: number;
  PRODUCTS_MICROSERVICE_HOST: string;
  PRODUCTS_MICROSERVICE_PORT: number;

  ORDERS_MICROSERVICE_HOST: string;
  ORDERS_MICROSERVICE_PORT: number;
}

<span class="hljs-keyword">const</span> envsSchema = joi.object({
  <span class="hljs-attr">PORT</span>: joi.number().required(),
  <span class="hljs-attr">PRODUCTS_MICROSERVICE_HOST</span>: joi.string().required(),
  <span class="hljs-attr">PRODUCTS_MICROSERVICE_PORT</span>: joi.number().required(),

  <span class="hljs-attr">ORDERS_MICROSERVICE_HOST</span>: joi.string().required(),
  <span class="hljs-attr">ORDERS_MICROSERVICE_PORT</span>: joi.number().required(),

})
.unknown(<span class="hljs-literal">true</span>);

<span class="hljs-keyword">const</span> { error, value } = envsSchema.validate( process.env );


<span class="hljs-keyword">if</span> ( error ) {
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Config validation error: <span class="hljs-subst">${ error.message }</span>`</span>);
}

<span class="hljs-keyword">const</span> envVars:EnvVars = value;


<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> envs = {
  <span class="hljs-attr">port</span>: envVars.PORT,
  
  <span class="hljs-attr">productsMicroserviceHost</span>: envVars.PRODUCTS_MICROSERVICE_HOST,
  <span class="hljs-attr">productsMicroservicePort</span>: envVars.PRODUCTS_MICROSERVICE_PORT,

  <span class="hljs-attr">ordersMicroserviceHost</span>: envVars.ORDERS_MICROSERVICE_HOST,
  <span class="hljs-attr">ordersMicroservicePort</span>: envVars.ORDERS_MICROSERVICE_PORT,


};
</div></code></pre>
<ul>
<li>En .env.template</li>
</ul>
<pre class="hljs"><code><div>PORT=<span class="hljs-number">3000</span>


PRODUCTS_MICROSERVICE_HOST=localhost
PRODUCTS_MICROSERVICE_PORT=<span class="hljs-number">3001</span>

ORDERS_MICROSERVICE_HOST=localhost
ORDERS_MICROSERVICE_PORT=<span class="hljs-number">3002</span>
</div></code></pre>
<ul>
<li>Inyecto el microservicio en el OrdersController del cliente-gateway usando el token de inyección, de tipo <strong>ClientProxy</strong></li>
<li>Con <strong>.send</strong> (porque espero una respuesta) le mando el string del @MessagePattern en orders-microservice.controller para conectar, y el dto o lo que sea que necesite si lo requiere</li>
<li>En el código hay cosas que se irán explicando sobre la marcha</li>
<li>cliente-gateway.controller</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Controller, Get, Post, Body, Param, Inject, ParseUUIDPipe, Query, Patch } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;


<span class="hljs-keyword">import</span> { ORDER_SERVICE } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/config'</span>;
<span class="hljs-keyword">import</span> { ClientProxy, RpcException } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/microservices'</span>;
<span class="hljs-keyword">import</span> { CreateOrderDto, OrderPaginationDto, StatusDto } <span class="hljs-keyword">from</span> <span class="hljs-string">'./dto'</span>;
<span class="hljs-keyword">import</span> { firstValueFrom } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;
<span class="hljs-keyword">import</span> { PaginationDto } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/common'</span>;

@Controller(<span class="hljs-string">'orders'</span>)
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrdersController</span> </span>{

  <span class="hljs-keyword">constructor</span>(
    @Inject(ORDER_SERVICE) private readonly ordersClient: ClientProxy,
  ) {}

  @Post()
  create(@Body() createOrderDto: CreateOrderDto) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.ordersClient.send(<span class="hljs-string">'createOrder'</span>, createOrderDto);
  }

  @Get()
  findAll( @Query() orderPaginationDto: OrderPaginationDto ) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.ordersClient.send(<span class="hljs-string">'findAllOrders'</span>, orderPaginationDto);
  }
  
  @Get(<span class="hljs-string">'id/:id'</span>)
  <span class="hljs-keyword">async</span> findOne(@Param(<span class="hljs-string">'id'</span>, ParseUUIDPipe ) id: string) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> order = <span class="hljs-keyword">await</span> firstValueFrom(
        <span class="hljs-keyword">this</span>.ordersClient.send(<span class="hljs-string">'findOneOrder'</span>, { id })
      );

      <span class="hljs-keyword">return</span> order;

    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(error);
    }
  }

  @Get(<span class="hljs-string">':status'</span>)
  <span class="hljs-keyword">async</span> findAllByStatus(
    @Param() statusDto: StatusDto,
    @Query() paginationDto: PaginationDto,
  ) {
    <span class="hljs-keyword">try</span> {

      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.ordersClient.send(<span class="hljs-string">'findAllOrders'</span>, {
        ...paginationDto,
        <span class="hljs-attr">status</span>: statusDto.status,
      });

    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(error);
    }
  }


  @Patch(<span class="hljs-string">':id'</span>)
  changeStatus(
    @Param(<span class="hljs-string">'id'</span>, ParseUUIDPipe ) id: string,
    @Body() statusDto: StatusDto,
  ) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.ordersClient.send(<span class="hljs-string">'changeOrderStatus'</span>, { id, <span class="hljs-attr">status</span>: statusDto.status })
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(error);
    }
  }
}
</div></code></pre>
<ul>
<li>En el orders-microservice.controller</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Controller, NotImplementedException, ParseUUIDPipe } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { MessagePattern, Payload } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/microservices'</span>;
<span class="hljs-keyword">import</span> { OrdersService } <span class="hljs-keyword">from</span> <span class="hljs-string">'./orders.service'</span>;
<span class="hljs-keyword">import</span> { CreateOrderDto } <span class="hljs-keyword">from</span> <span class="hljs-string">'./dto/create-order.dto'</span>;
<span class="hljs-keyword">import</span> { OrderPaginationDto } <span class="hljs-keyword">from</span> <span class="hljs-string">'./dto/order-pagination.dto'</span>;
<span class="hljs-keyword">import</span> { ChangeOrderStatusDto } <span class="hljs-keyword">from</span> <span class="hljs-string">'./dto'</span>;

@Controller()
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrdersController</span> </span>{
  <span class="hljs-keyword">constructor</span>(private readonly ordersService: OrdersService) {}

  @MessagePattern(<span class="hljs-string">'createOrder'</span>)
  create(@Payload() createOrderDto: CreateOrderDto) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.ordersService.create(createOrderDto);
  }

  @MessagePattern(<span class="hljs-string">'findAllOrders'</span>)
  findAll(@Payload() orderPaginationDto: OrderPaginationDto ) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.ordersService.findAll(orderPaginationDto);
  }

  @MessagePattern(<span class="hljs-string">'findOneOrder'</span>)
  findOne(@Payload(<span class="hljs-string">'id'</span>, ParseUUIDPipe ) id: string) { <span class="hljs-comment">//Si recojo el id, debo pasarlo en el payload (y lo parseo)</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.ordersService.findOne(id);
  }

  @MessagePattern(<span class="hljs-string">'changeOrderStatus'</span>)
  changeOrderStatus(@Payload() changeOrderStatusDto: ChangeOrderStatusDto ) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.ordersService.changeStatus(changeOrderStatusDto)

  }
}
</div></code></pre>
<ul>
<li>Una vez probado que los endpoints se comunican corectamente, Orders debe crear la base de datos y hay que desarrollar la lógica en el servicio</li>
</ul>
<hr>
<h2 id="docker---levantar-postgresql">Docker - Levantar PostgreSQL</h2>
<ul>
<li>Si no quieres usar Docker puedes usar neon.tch, ofrecen un ServerLess Postgres (tienes un espacio gratuito para trabajar con PostgreSQL con limitaciones)</li>
<li>Aqui lo haremos con Docker</li>
<li>En la raíz de orders-microservice creo el docker-compose.yml- Para obtener la info de como generar volúmenes, puedes consultar en Docker-hub, en la imagen de la DB PostgreSQL</li>
<li>Le estoy diciendo que enlace mi carpeta postgres de mi fileSystem con la ruta del fs del contenedor</li>
<li>Pongo un puerto que no esté ocupado</li>
<li>No uso variables de entorno porque en producción no voy a usar Docker, voy a usar algún servicio</li>
</ul>
<pre class="hljs"><code><div> <span class="hljs-attr">version:</span> <span class="hljs-string">'3'</span>


<span class="hljs-attr">services:</span>
  <span class="hljs-attr">orders-db:</span>
    <span class="hljs-attr">container_name:</span> <span class="hljs-string">orders_database</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">postgres:16.2</span>
    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">./postgres:/var/lib/postgresql/data</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-number">5434</span><span class="hljs-string">:5432</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">POSTGRES_USER=postgres</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">POSTGRES_PASSWORD=123456</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">POSTGRES_DB=ordersdb</span>
</div></code></pre>
<ul>
<li>Ejecuto (con Docker abierto corrriendo) en la raiz del proyecto</li>
<li>Con el -d el container no se bajará si se cierra la terminal</li>
</ul>
<blockquote>
<p>docker-compose -d</p>
</blockquote>
<ul>
<li>En .gitignore coloco postgres/</li>
<li>Me puedo conectar con Table Plus creando la conexión</li>
<li>Vamos con Prisma</li>
</ul>
<hr>
<h2 id="modelo-y-conexi%C3%B3n">Modelo y conexión</h2>
<ul>
<li>Está en la documentación de Nest cómo generar una cosa y otra usando Prisma</li>
<li>Básicamente <strong>instalo prisma</strong> con <strong>npm</strong>, uso npx prisma, npx prisma init,</li>
<li>Esto crea una conexión postgres automática en .env</li>
<li>La cambio y coloco la mía, con el password y user que le puse en el docker file</li>
<li>Al ser una base de datos de desarrollo coloco pública la cadena de conexión</li>
</ul>
<pre class="hljs"><code><div>DATABASE_URL=<span class="hljs-string">"postgresql://postgres:123456@localhost:5434/ordersdb?schema=public"</span>
</div></code></pre>
<ul>
<li>Instalo el cliente de prisma con npm i @prisma/client</li>
<li>Creo el schema en Prisma</li>
<li>Creo un enum con los status</li>
<li>Creo el modelo en orders-microservice/prisma/schema.prisma</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// This is your Prisma schema file,</span>
<span class="hljs-comment">// learn more about it in the docs: https://pris.ly/d/prisma-schema</span>

<span class="hljs-comment">// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?</span>
<span class="hljs-comment">// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init</span>

generator client {
  provider = <span class="hljs-string">"prisma-client-js"</span>
}

datasource db {
  provider = <span class="hljs-string">"postgresql"</span>
  url      = env(<span class="hljs-string">"DATABASE_URL"</span>)
}

enum OrderStatus {
  PENDING
  DELIVERED
  CANCELLED
}

model Order {
  id          <span class="hljs-built_in">String</span> @id @<span class="hljs-keyword">default</span>(uuid()) <span class="hljs-comment">//uso uuid com id, @id crea el índice la llave primaria,etc</span>
  totalAmount Float  <span class="hljs-comment">//El total de la orden</span>
  totalItems  Int   <span class="hljs-comment">//cantidad de items</span>

  status OrderStatus  <span class="hljs-comment">//status de la orden</span>
  paid   <span class="hljs-built_in">Boolean</span>     @<span class="hljs-keyword">default</span>(<span class="hljs-literal">false</span>)  <span class="hljs-comment">//está pagada o no</span>
  paidAt DateTime?                    <span class="hljs-comment">//pagada cuando</span>

  createdAt DateTime @<span class="hljs-keyword">default</span>(now())  <span class="hljs-comment">//valor por defecto now()</span>
  updatedAt DateTime @updatedAt       <span class="hljs-comment">//@updatedAt es una función propia</span>
}
</div></code></pre>
<ul>
<li>Quizá sería más conveniente crear otra tabla con las pagadas y añadir el paidAt</li>
<li>Ejecuto el comando <strong>npx prisma migrate dev --name init</strong></li>
<li>Se crea el cliente y se actualiza la DB</li>
<li>Si todo va bien, aparecen los campos de Orders en tablePlus (!)</li>
<li>Para terminar creamos un Logger en orders-microservice.service y conectamos con Prisma usando la herencia con PrismaCLient (que lo acabamos de instalar) e implementamos la interfaz de OnModuleInit que nos obliga al método onModuleInit para conectarnos con la DB</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { HttpStatus, Injectable, Logger, OnModuleInit } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { CreateOrderDto } <span class="hljs-keyword">from</span> <span class="hljs-string">'./dto/create-order.dto'</span>;
<span class="hljs-keyword">import</span> { PrismaClient } <span class="hljs-keyword">from</span> <span class="hljs-string">'@prisma/client'</span>;
<span class="hljs-keyword">import</span> { RpcException } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/microservices'</span>;
<span class="hljs-keyword">import</span> { OrderPaginationDto } <span class="hljs-keyword">from</span> <span class="hljs-string">'./dto/order-pagination.dto'</span>;
<span class="hljs-keyword">import</span> { ChangeOrderStatusDto } <span class="hljs-keyword">from</span> <span class="hljs-string">'./dto'</span>;


@Injectable()
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrdersService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PrismaClient</span> <span class="hljs-title">implements</span> <span class="hljs-title">OnModuleInit</span> </span>{

  private readonly logger = <span class="hljs-keyword">new</span> Logger(<span class="hljs-string">'OrdersService'</span>);


  <span class="hljs-keyword">async</span> onModuleInit() {
    <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.$connect();
    <span class="hljs-keyword">this</span>.logger.log(<span class="hljs-string">'Database connected'</span>);
  }
}
</div></code></pre>
<hr>
<h2 id="crear-una-nueva-orden">Crear una nueva orden</h2>
<ul>
<li>'orders' está en el decorador @Controller('orders') de orders-microservice.controller y también en el decorador del cliente-gateway.orders.controller. Los dos apuntan a orders</li>
<li>Me creo el dto en orders-microservice (debo instalar class-validator y class-transformer)</li>
<li>Debo configurar tambien el useGlobalPipes en el main</li>
<li>Para utilizar el enum uso @IsEnum, le paso el listado y envío un mensaje dentro de un objeto</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { IsBoolean, IsEnum, IsNumber, IsOptional, IsPositive } <span class="hljs-keyword">from</span> <span class="hljs-string">'class-validator'</span>;
<span class="hljs-keyword">import</span> { OrderStatus, OrderStatusList } <span class="hljs-keyword">from</span> <span class="hljs-string">'../enum/order.enum'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateOrderDto</span> </span>{


  @IsNumber()
  @IsPositive()
  <span class="hljs-attr">totalAmount</span>: number;

  @IsNumber()
  @IsPositive()
  <span class="hljs-attr">totalItems</span>: number;

  @IsEnum( OrderStatusList, {
    <span class="hljs-attr">message</span>: <span class="hljs-string">`Possible status values are <span class="hljs-subst">${ OrderStatusList }</span>`</span>
  })
  @IsOptional()
  <span class="hljs-attr">status</span>: OrderStatus = OrderStatus.PENDING <span class="hljs-comment">//por defecto pongo PENDING</span>

  @IsBoolean()
  @IsOptional()
  <span class="hljs-attr">paid</span>: boolean = <span class="hljs-literal">false</span>; <span class="hljs-comment">//por defecto pongo false</span>
}
</div></code></pre>
<ul>
<li>Uso de useGlobalPipes</li>
</ul>
<pre class="hljs"><code><div>app.useGlobalPipes(
  <span class="hljs-keyword">new</span> ValidationPipe({
    <span class="hljs-attr">whitelist</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">forbidNonWhitelisted</span>: <span class="hljs-literal">true</span>,
  }),
);
</div></code></pre>
<ul>
<li>El cliente-gateway tiene el mismo dto, con el status y el paid con valores por defecto</li>
<li>En cliente-gateway.orders.enum (order.enum.ts) tengo el OrderStatus (que también creé sin valores como string en el schema de prisma de orders.microservice)</li>
<li>Y creo también el array con la OrderStatusList usando OrderStatus (estoy en el cliente-gateway)</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> enum OrderStatus {
  PENDING = <span class="hljs-string">'PENDING'</span>,
  DELIVERED = <span class="hljs-string">'DELIVERED'</span>,
  CANCELLED = <span class="hljs-string">'CANCELLED'</span>,
}


<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> OrderStatusList = [
  OrderStatus.PENDING,
  OrderStatus.DELIVERED,
  OrderStatus.CANCELLED,
]
</div></code></pre>
<ul>
<li>En el enum de orders-microservice , ya tengo el OrderStatus en el PrismaClient (desde el schema)</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { OrderStatus } <span class="hljs-keyword">from</span> <span class="hljs-string">'@prisma/client'</span>;


<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> OrderStatusList = [
  OrderStatus.PENDING,
  OrderStatus.DELIVERED,
  OrderStatus.CANCELLED,
]
</div></code></pre>
<ul>
<li>El schema en orders-microservice (extracto)</li>
</ul>
<pre class="hljs"><code><div>enum OrderStatus {
  PENDING     <span class="hljs-comment">//no tiene valores (strings) asignados pero si lo están en el cliente-gateway</span>
  DELIVERED
  CANCELLED
}

model Order {
  id          <span class="hljs-built_in">String</span> @id @<span class="hljs-keyword">default</span>(uuid())
  totalAmount Float
  totalItems  Int

  status OrderStatus <span class="hljs-comment">//se lo estoy pasando aqui</span>
  paid   <span class="hljs-built_in">Boolean</span>     @<span class="hljs-keyword">default</span>(<span class="hljs-literal">false</span>)
  paidAt DateTime?

  createdAt DateTime @<span class="hljs-keyword">default</span>(now())
  updatedAt DateTime @updatedAt
}
</div></code></pre>
<ul>
<li>Ya tenemos el dto para el cliente y tenemos el otro dto para el microservicio (que son iguales)</li>
<li>Importo el dto en el controlador del cliente-gateway para pasarselo al @Post</li>
<li>Vamos con el orders-microservice.service</li>
<li>No hace falta que inyecte nada en el servicio porque trabajo con el cliente de Prisma, y mi servicio hereda de PrismaClient y ya está conectado a la DB con onModuleInit</li>
<li>Uso this.order, order porque en el schema le pusimos Order al modelo</li>
<li>Le paso en la data el dto para hacer la isnerción con .create</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { HttpStatus, Injectable, Logger, OnModuleInit } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { CreateOrderDto } <span class="hljs-keyword">from</span> <span class="hljs-string">'./dto/create-order.dto'</span>;
<span class="hljs-keyword">import</span> { PrismaClient } <span class="hljs-keyword">from</span> <span class="hljs-string">'@prisma/client'</span>;
<span class="hljs-keyword">import</span> { RpcException } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/microservices'</span>;
<span class="hljs-keyword">import</span> { OrderPaginationDto } <span class="hljs-keyword">from</span> <span class="hljs-string">'./dto/order-pagination.dto'</span>;
<span class="hljs-keyword">import</span> { ChangeOrderStatusDto } <span class="hljs-keyword">from</span> <span class="hljs-string">'./dto'</span>;


@Injectable()
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrdersService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PrismaClient</span> <span class="hljs-title">implements</span> <span class="hljs-title">OnModuleInit</span> </span>{

  private readonly logger = <span class="hljs-keyword">new</span> Logger(<span class="hljs-string">'OrdersService'</span>);


  <span class="hljs-keyword">async</span> onModuleInit() {
    <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.$connect();
    <span class="hljs-keyword">this</span>.logger.log(<span class="hljs-string">'Database connected'</span>);
  }

  create(createOrderDto: CreateOrderDto) {
    
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.order.create({
      <span class="hljs-attr">data</span>: createOrderDto
    })

  }
</div></code></pre>
<ul>
<li>Para insertar apunto a http://localhost:3000/api/orders y le paso lo que me pide el dto</li>
</ul>
<pre class="hljs"><code><div>{
  <span class="hljs-attr">"totalAmount"</span>:<span class="hljs-number">135</span>,
  <span class="hljs-attr">"totalItems"</span>:<span class="hljs-number">4</span>
  
}
</div></code></pre>
<ul>
<li>Esto devuelve algo como esto</li>
</ul>
<pre class="hljs"><code><div>{
  <span class="hljs-attr">"id"</span>: <span class="hljs-string">"34fc8622-44c0-4775-a491-8f8db607967e"</span>,
  <span class="hljs-attr">"totalAmount"</span>: <span class="hljs-number">135</span>,
  <span class="hljs-attr">"totalItems"</span>: <span class="hljs-number">4</span>,
  <span class="hljs-attr">"status"</span>: <span class="hljs-string">"PENDING"</span>,
  <span class="hljs-attr">"paid"</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">"paidAt"</span>: <span class="hljs-literal">null</span>, <span class="hljs-comment">//puede ser que yo no quiera valores null en mi tabla, por lo que tendría que crear una para paid y paidAt</span>
  <span class="hljs-attr">"createdAt"</span>: <span class="hljs-string">"2024-05-02T13:09:57.905Z"</span>,
  <span class="hljs-attr">"updatedAt"</span>: <span class="hljs-string">"2024-05-02T13:09:57.905Z"</span>
}
</div></code></pre>
<hr>
<h2 id="obtener-orden-por-id">Obtener orden por ID</h2>
<ul>
<li>Copio un uuid de alguna order en TablePlus</li>
<li>Lo paso en el endpoint de THUNDERCLIENT/POSTMAN orders/UUId-6456500uu-65656i-DUU-665656IDuuiD</li>
<li>Primero nos aseguramos que desde cliente-gateway le mandemos el id</li>
<li>Si en lugar de tratar como un Observable lo que devuelve .send y usar el catchError lo quiero tratar como una promesa con async await, debo usar firstValueFrom en un try catch, y atrapar la RpcException en el catch</li>
</ul>
<pre class="hljs"><code><div>@Get(<span class="hljs-string">'id/:id'</span>)
<span class="hljs-keyword">async</span> findOne(@Param(<span class="hljs-string">'id'</span>, ParseUUIDPipe ) id: string) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> order = <span class="hljs-keyword">await</span> firstValueFrom(
      <span class="hljs-keyword">this</span>.ordersClient.send(<span class="hljs-string">'findOneOrder'</span>, { id })
    );

    <span class="hljs-keyword">return</span> order;

  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(error);
  }
}
</div></code></pre>
<ul>
<li>En el orders-microservice.service busco que exista y si no existe envio la RpcException.</li>
<li>Si existe la order retorno</li>
<li><em>NOTA</em>: sigo el mismo patrón siempre en las RpcException de incluir message y status para que todo vaya bien con el ExceptionFilter</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">async</span> findOne(id: string) {
  <span class="hljs-keyword">const</span> order = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.order.findFirst({
    <span class="hljs-attr">where</span>: { id }
  });

  <span class="hljs-keyword">if</span> ( !order ) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException({ 
      <span class="hljs-attr">status</span>: HttpStatus.NOT_FOUND, 
      <span class="hljs-attr">message</span>: <span class="hljs-string">`Order with id <span class="hljs-subst">${ id }</span> not found`</span>
    });
  }

  <span class="hljs-keyword">return</span> order;

}
</div></code></pre>
<ul>
<li>EN THUNDERCLIENT apunto con un GET a http://localhost:3000/api/orders/id/34fc8622-44c0-4775-a491-8f8db607967e (un UUID válido)</li>
</ul>
<hr>
<h2 id="paginaci%C3%B3n-y-filtro-findall">Paginación y Filtro (findAll)</h2>
<ul>
<li>Crea varias órdenes</li>
<li>Algunas ponlas canceladas y entregadas desde TablePlus</li>
<li>En el controlador del cliente-gateway recojo de las Query y valido la data con orderPaginationDto</li>
<li>En el .send primero le paso el string que es el mismo que me conecta desde MessagePattern con el orders-microservice.controller</li>
</ul>
<pre class="hljs"><code><div>@Get()
  findAll( @Query() orderPaginationDto: OrderPaginationDto ) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.ordersClient.send(<span class="hljs-string">'findAllOrders'</span>, orderPaginationDto);
  }
</div></code></pre>
<ul>
<li>El dto de orderPaginationDto quiero filtrar a través del status</li>
<li>Extiendo de PaginationDto para tener las mismas propiedades opcionales de PaginationDto disponibles</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { IsEnum, IsOptional } <span class="hljs-keyword">from</span> <span class="hljs-string">'class-validator'</span>;
<span class="hljs-keyword">import</span> { PaginationDto } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/common'</span>;
<span class="hljs-keyword">import</span> { OrderStatus, OrderStatusList } <span class="hljs-keyword">from</span> <span class="hljs-string">'../enum/order.enum'</span>;


<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderPaginationDto</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PaginationDto</span> </span>{


  @IsOptional()
  @IsEnum( OrderStatusList, {
    <span class="hljs-attr">message</span>: <span class="hljs-string">`Valid status are <span class="hljs-subst">${ OrderStatusList }</span>`</span>
  })
  <span class="hljs-attr">status</span>: OrderStatus;

}
</div></code></pre>
<ul>
<li>En el controlador de orders-microservice tenemos el mismo dto (este alojado en el microservicio Orders/src/orders/dto)</li>
<li>Me interesa filtrar por el status</li>
<li>Como el dto extiende de paginationDto, tengo disponibles pages y limit que son opcionales</li>
</ul>
<pre class="hljs"><code><div>@MessagePattern(<span class="hljs-string">'findAllOrders'</span>)
  findAll(@Payload() orderPaginationDto: OrderPaginationDto ) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.ordersService.findAll(orderPaginationDto);
  }
</div></code></pre>
<ul>
<li>En el servico de orders-microservice en el que me comunico con el cliente de Prsima para trabajar con la db a través del modelo y el cliente</li>
<li>Con .count tengo el total de elementos, pasándole la condicion en el objeto de where</li>
<li>Establezco la currentPage y el limite por página</li>
<li>En el return, en el objeto data, con un await utilizo .findMany y hago la paginación</li>
<li>En meta coloco la info que me parece interesante
<ul>
<li>Coloco la cantidad total de elementos filtrados por el status</li>
<li>Coloco la página donde estoy</li>
<li>Coloco el total de páginas (Math.ceil sirve para redondear)</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">async</span> findAll(orderPaginationDto: OrderPaginationDto) {

  <span class="hljs-comment">//para tener el total de elementos según el status</span>
  <span class="hljs-keyword">const</span> totalPages = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.order.count({
    <span class="hljs-attr">where</span>: {
      <span class="hljs-attr">status</span>: orderPaginationDto.status
    }
  });

  <span class="hljs-keyword">const</span> currentPage = orderPaginationDto.page; <span class="hljs-comment">//como orderPaginationDto extiende de paginationDto, tengo disponible page</span>
  <span class="hljs-keyword">const</span> perPage = orderPaginationDto.limit; <span class="hljs-comment">//también limit</span>


  <span class="hljs-keyword">return</span> {
    <span class="hljs-comment">//hago la paginación, que siempre es la misma cosa</span>
    <span class="hljs-attr">data</span>: <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.order.findMany({
      <span class="hljs-attr">skip</span>: ( currentPage - <span class="hljs-number">1</span> ) * perPage,
      <span class="hljs-attr">take</span>: perPage,
      <span class="hljs-attr">where</span>: {
        <span class="hljs-attr">status</span>: orderPaginationDto.status
      }
    }),
    <span class="hljs-attr">meta</span>: {
      <span class="hljs-attr">total</span>: totalPages,
      <span class="hljs-attr">page</span>: currentPage,
      <span class="hljs-attr">lastPage</span>: <span class="hljs-built_in">Math</span>.ceil( totalPages / perPage )
    }
  }
}
</div></code></pre>
<hr>
<h2 id="cambiar-estado-de-la-orden">Cambiar estado de la orden</h2>
<ul>
<li>En el controlador del cliente-gateway , en orders, uso @Patch</li>
<li>De los parámetros extraemos el id, lo casteamos a un UUID, viene a ser un id de tipo string</li>
<li>En el body tenemos el status (que debe coincidir con alguno de los del enum)</li>
<li>Pasamos el id y el status que lo guardamos de statusDto.status</li>
<li>metemos el .send en un try catch</li>
<li>Lanzamos la RpcException en el catch</li>
</ul>
<pre class="hljs"><code><div>  @Patch(<span class="hljs-string">':id'</span>)
  <span class="hljs-keyword">async</span> changeStatus(
    @Param(<span class="hljs-string">'id'</span>, ParseUUIDPipe ) id: string,
    @Body() statusDto: StatusDto,
  ) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.ordersClient.send(<span class="hljs-string">'changeOrderStatus'</span>, { id, <span class="hljs-attr">status</span>: statusDto.status })
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(error);
    }
  }
</div></code></pre>
<ul>
<li>El statusDto está alojado en cliente-gateway/src/orders/dto</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { IsEnum, IsOptional } <span class="hljs-keyword">from</span> <span class="hljs-string">'class-validator'</span>;
<span class="hljs-keyword">import</span> { OrderStatus, OrderStatusList } <span class="hljs-keyword">from</span> <span class="hljs-string">'../enum/order.enum'</span>;



<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StatusDto</span> </span>{


  @IsOptional()
  @IsEnum( OrderStatusList, {
    <span class="hljs-attr">message</span>: <span class="hljs-string">`Valid status are <span class="hljs-subst">${ OrderStatusList }</span>`</span>
  })
  <span class="hljs-attr">status</span>: OrderStatus;

}
</div></code></pre>
<ul>
<li>En el orders-microservice.controller dentro de MessagePattern tenemos el mismo string que hemos usado en el cliente-gateway.orders.controller, y en el Payload le pasamos el dto</li>
</ul>
<pre class="hljs"><code><div>@MessagePattern(<span class="hljs-string">'changeOrderStatus'</span>)
changeOrderStatus(@Payload() changeOrderStatusDto: ChangeOrderStatusDto ) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.ordersService.changeStatus(changeOrderStatusDto)

}
</div></code></pre>
<ul>
<li>El changeOrderStatusDto de orders-microservice.change-order-status.dto contiene un id (tipo UUID versión 4) y el status</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { OrderStatus } <span class="hljs-keyword">from</span> <span class="hljs-string">'@prisma/client'</span>;
<span class="hljs-keyword">import</span> { IsEnum, IsUUID } <span class="hljs-keyword">from</span> <span class="hljs-string">'class-validator'</span>;
<span class="hljs-keyword">import</span> { OrderStatusList } <span class="hljs-keyword">from</span> <span class="hljs-string">'../enum/order.enum'</span>;



<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChangeOrderStatusDto</span> </span>{

  @IsUUID(<span class="hljs-number">4</span>)
  <span class="hljs-attr">id</span>: string;

  @IsEnum( OrderStatusList, {
    <span class="hljs-attr">message</span>: <span class="hljs-string">`Valid status are <span class="hljs-subst">${ OrderStatusList }</span>`</span>
  })
  <span class="hljs-attr">status</span>: OrderStatus;
}
</div></code></pre>
<ul>
<li>En orders-microservice.service extraigo el id y el status con desestructuración</li>
<li>Busco por id con findOne. Si el status a actualizar es el mismo que el de la orden encontrada, devuelvo la orden tal cual</li>
<li>Si no uso el .update, busco con el where por el id y en el objeto data cambio el status</li>
<li>Puedo colocarlo en el return directamente</li>
</ul>
<pre class="hljs"><code><div> <span class="hljs-keyword">async</span> changeStatus(changeOrderStatusDto: ChangeOrderStatusDto) {

    <span class="hljs-keyword">const</span> { id, status } = changeOrderStatusDto;

    <span class="hljs-keyword">const</span> order = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.findOne(id);
    <span class="hljs-keyword">if</span> ( order.status === status ) {
      <span class="hljs-keyword">return</span> order;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.order.update({
      <span class="hljs-attr">where</span>: { id },
      <span class="hljs-attr">data</span>: { <span class="hljs-attr">status</span>: status }
    });
  }
</div></code></pre>
<hr>
<h1 id="04--nest-microservciios---detalles">04- NEST MICROSERVCIIOS - DETALLES</h1>
<ul>
<li>Vamos a conectar Ordenes con Productos directamente para comprobar que los productos existen</li>
<li>Debemos cambiar el dto de creacion de la orden para aceptar los tems, en orders igual</li>
<li>Hay que crear en Products algún método para recibir el id de los productos y verificar que existen</li>
<li>No voy a poder crear una orden si un producto no existe</li>
<li>Es conveniente que inttroduzcamos algun tipo de middleman como NATS o RabbitMQ, algun sistema que mantenga el orden en este caos de tanto microservicio</li>
</ul>
<hr>
<h2 id="orders-microservice">Orders-microservice</h2>
<ul>
<li>Ordenes y detalle van a estar en el mismo microservicio</li>
<li>Ambos están altamente acoplados, uno no va a existir sin el otro</li>
<li>Comunicaremos ordenes y productos mediante TCP para validar</li>
<li>Despues de esta sección implementaremos un middleman entre el cliente y los microservicios (un servidor NATS)</li>
<li>Habrá otro microservicio de autenticación con MONGO</li>
<li>Vamos con el desarrollo. Levantamos Docker, Orders y el cliente</li>
<li>Uso docker-compose up -d en orders-microservice</li>
</ul>
<hr>
<h2 id="orderitems---detalles-de-la-orden">OrderItems - detalles de la orden</h2>
<ul>
<li>En orders-microservice</li>
<li>Para entender la comunicación que vamos a establecer, lo mejor es entender la estructura de la DB</li>
<li>Practicamente, excepto totalAmount y totalItems, el resto de campos se crean automáticamente</li>
<li>Voy a pedir siempre una cantidad de hijos (items) y esos items los voy a contar y sumar su valor para el totalAmount</li>
<li>Una orden en la vida real podría tener más cosas, como un cupón de descuento</li>
<li>Creo otro modelo como OrderItem</li>
<li>productId no tiene una relación directa con SQLite de Products
<ul>
<li>Hay quien trabaja todo en un amisma DB, pero no son buenas practicas en microservicios</li>
<li>Se puede hacer, pero no permitiría escalar cada microservicio de manera independiente</li>
</ul>
</li>
<li>Si yo coloco esto en Order</li>
</ul>
<pre class="hljs"><code><div>OrderItem OrderItem[]
</div></code></pre>
<ul>
<li>y PRESIONO CTRL+aLT+SHIFT me creará la relación automáticamente</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// This is your Prisma schema file,</span>
<span class="hljs-comment">// learn more about it in the docs: https://pris.ly/d/prisma-schema</span>

<span class="hljs-comment">// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?</span>
<span class="hljs-comment">// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init</span>

generator client {
  provider = <span class="hljs-string">"prisma-client-js"</span>
}

datasource db {
  provider = <span class="hljs-string">"postgresql"</span>
  url      = env(<span class="hljs-string">"DATABASE_URL"</span>)
}

enum OrderStatus {
  PENDING
  DELIVERED
  CANCELLED
}

model Order {
  id          <span class="hljs-built_in">String</span> @id @<span class="hljs-keyword">default</span>(uuid())
  totalAmount Float
  totalItems  Int

  status OrderStatus @<span class="hljs-keyword">default</span>(PENDING) <span class="hljs-comment">//establezco PENDING por defecto</span>
  paid   <span class="hljs-built_in">Boolean</span>     @<span class="hljs-keyword">default</span>(<span class="hljs-literal">false</span>)   <span class="hljs-comment">//false por defecto</span>
  paidAt DateTime?

  createdAt DateTime @<span class="hljs-keyword">default</span>(now())
  updatedAt DateTime @updatedAt

  OrderItem OrderItem[]  <span class="hljs-comment">//</span>
}

model OrderItem {
  id        <span class="hljs-built_in">String</span> @id @<span class="hljs-keyword">default</span>(uuid())
  productId Int  <span class="hljs-comment">//no hay una relación (física) directa con SQLite</span>
  quantity  Int  <span class="hljs-comment">//cantidad de este producto</span>
  price     Float  <span class="hljs-comment">//los precios pueden variar. Este precio se queda aqui en el momento que se creó la orden</span>

  Order   Order?  @relation(fields: [orderId], <span class="hljs-attr">references</span>: [id]) <span class="hljs-comment">//establezco la relación</span>
  orderId <span class="hljs-built_in">String</span>?
}
</div></code></pre>
<ul>
<li>Desde orders-microservice impacto la db con una migracion</li>
</ul>
<blockquote>
<p>npx prisma migrate dev --name order-item</p>
</blockquote>
<ul>
<li>Debes tener Docker corriendo y poder establecer conexión con el puerto correcto y la autenticación</li>
<li>Puedo mirar en TablePlus</li>
<li>Borro las ordenes anteriores porque estan mal creaqdas, les falta el OrderItem</li>
</ul>
<hr>
<h2 id="dtos-de-creaci%C3%B3n-de-orden">DTOs de creación de orden</h2>
<ul>
<li>Para orders-microservice.create-order.dto pido un Array de minimo 1 elemento de tipo item: orderItemDto</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { ArrayMinSize, IsArray, ValidateNested } <span class="hljs-keyword">from</span> <span class="hljs-string">'class-validator'</span>;

<span class="hljs-keyword">import</span> { OrderItemDto } <span class="hljs-keyword">from</span> <span class="hljs-string">'./order-item.dto'</span>;
<span class="hljs-keyword">import</span> { Type } <span class="hljs-keyword">from</span> <span class="hljs-string">'class-transformer'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateOrderDto</span> </span>{
  @IsArray()
  @ArrayMinSize(<span class="hljs-number">1</span>) <span class="hljs-comment">//por lo menos un item</span>
  @ValidateNested({ <span class="hljs-attr">each</span>: <span class="hljs-literal">true</span> }) <span class="hljs-comment">//valida internamente los objetos en el array</span>
  @Type(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> OrderItemDto) <span class="hljs-comment">//ojo! no pongo que es un arreglo</span>
  <span class="hljs-attr">items</span>: OrderItemDto[]; <span class="hljs-comment">//aquí si indico que es un arreglo</span>
}
</div></code></pre>
<ul>
<li>En order-item.dto tengo productId, quantity y price</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { IsNumber, IsPositive } <span class="hljs-keyword">from</span> <span class="hljs-string">'class-validator'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderItemDto</span> </span>{
  @IsNumber()
  @IsPositive()
  <span class="hljs-attr">productId</span>: number; <span class="hljs-comment">//En la DB de productos los productos tienen id de tipo numérico</span>

  @IsNumber()
  @IsPositive()
  <span class="hljs-attr">quantity</span>: number;

  @IsNumber()
  @IsNumber()
  <span class="hljs-attr">price</span>: number;
}
</div></code></pre>
<ul>
<li>Esto vendría a pedir algo asi en POSTMAN</li>
</ul>
<pre class="hljs"><code><div>{
    <span class="hljs-attr">"items"</span>:[
        {
            <span class="hljs-attr">"productId"</span>: <span class="hljs-number">4</span> ,
            <span class="hljs-attr">"quantity"</span>: <span class="hljs-number">3</span>,
            <span class="hljs-attr">"price"</span>: <span class="hljs-number">20</span>
        }
    ]
}
</div></code></pre>
<ul>
<li>Pero esto solo valida la petición en orders-microservice</li>
<li><strong>Hay que hacer lo mismo en cliente-gateway</strong></li>
<li>En cliente-gateway.orders.create-oder.dto es el mismo código</li>
<li>En cliente-gateway.orders.order-item.dto también es el mismo código</li>
<li>En el método create de orders-microservice.service voy a tener un error porque prsima valida el dto</li>
<li>Coloco un return {service: &quot;orders-service create&quot;, createOrderDto} devolviendo el dto</li>
<li><strong>Falta validar que los productos de la orden existan</strong></li>
</ul>
<hr>
<h2 id="products-microservice---validar-productos-por-id">Products-microservice - Validar productos por ID</h2>
<ul>
<li>En products-microservice estoy trabajando con SQLite (la abro en TablePlus) donde tengo la data</li>
<li>Abro el products-microservice.controller y creo el controlador</li>
</ul>
<pre class="hljs"><code><div>@MessagePattern({ <span class="hljs-attr">cmd</span>: <span class="hljs-string">'validate_products'</span> })
validateProduct( @Payload() ids: number[] ) {
<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.productsService.validateProducts(ids);
}
</div></code></pre>
<ul>
<li>En products-microservice.service creo un array  de id's y utilizo Set para eliminar los id's repetidos</li>
<li>Hago la búsqueda con findMany le digo que el id debe estar en el arreglo ids con <strong>where:{id:{in: ids}}</strong></li>
<li>Si la cantidad de productos encontrados no coincide con la cantidad del array de ids es que algunos productos no los ha encontrado</li>
<li>Retorno products</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">async</span> validateProducts(ids: number[]) {
ids = <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(ids));

<span class="hljs-keyword">const</span> products = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.product.findMany({
    <span class="hljs-attr">where</span>: {
    <span class="hljs-attr">id</span>: {
        <span class="hljs-attr">in</span>: ids
    }
    }
});

<span class="hljs-keyword">if</span> ( products.length !== ids.length ) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException({
    <span class="hljs-attr">message</span>: <span class="hljs-string">'Some products were not found'</span>,
    <span class="hljs-attr">status</span>: HttpStatus.BAD_REQUEST,
    });
}


<span class="hljs-keyword">return</span> products;

}
</div></code></pre>
<hr>
<h2 id="comunicar-orders-microservice-con-products-microservice">Comunicar orders-microservice con products-microservice</h2>
<ul>
<li>En orders-microservice tengo que registrar el products-microservice con ClientsModule.register</li>
<li>Voy a necesitar añadir las variables de entorno en .env de orders-microservice</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Module } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { OrdersService } <span class="hljs-keyword">from</span> <span class="hljs-string">'./orders.service'</span>;
<span class="hljs-keyword">import</span> { OrdersController } <span class="hljs-keyword">from</span> <span class="hljs-string">'./orders.controller'</span>;
<span class="hljs-keyword">import</span> { ClientsModule, Transport } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/microservices'</span>;
<span class="hljs-keyword">import</span> { PRODUCT_SERVICE, envs } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/config'</span>;

@Module({
  <span class="hljs-attr">controllers</span>: [OrdersController],
  <span class="hljs-attr">providers</span>: [OrdersService],
  <span class="hljs-attr">imports</span>: [
    <span class="hljs-comment">// ClientsModule.register......</span>
    ClientsModule.register([

      {
        <span class="hljs-attr">name</span>: PRODUCT_SERVICE,
        <span class="hljs-attr">transport</span>: Transport.TCP, <span class="hljs-comment">//después usaremos NATS!!!</span>
        <span class="hljs-attr">options</span>: {
          <span class="hljs-attr">host</span>: envs.productsMicroserviceHost,
          <span class="hljs-attr">port</span>: envs.productsMicroservicePort,
        }
      }


    ])
  ]
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrdersModule</span> </span>{}
</div></code></pre>
<ul>
<li>orders-microservice .env</li>
</ul>
<pre class="hljs"><code><div>PORT=3002

PRODUCTS_MICROSERVICE_HOST=localhost
PRODUCTS_MICROSERVICE_PORT=3001

DATABASE_URL=&quot;postgresql://postgres:123456@localhost:5434/ordersdb?schema=public&quot;
</div></code></pre>
<ul>
<li>También debo añadirlas en el archivo de configuración de envs.ts de orders-microservice!!</li>
<li>envs.ts</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> <span class="hljs-string">'dotenv/config'</span>;

<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> joi <span class="hljs-keyword">from</span> <span class="hljs-string">'joi'</span>;

interface EnvVars {
  <span class="hljs-attr">PORT</span>: number;
  
  PRODUCTS_MICROSERVICE_HOST: string;
  PRODUCTS_MICROSERVICE_PORT: number;
}

<span class="hljs-keyword">const</span> envsSchema = joi.object({
  <span class="hljs-attr">PORT</span>: joi.number().required(),
  
  <span class="hljs-attr">PRODUCTS_MICROSERVICE_HOST</span>: joi.string().required(),
  <span class="hljs-attr">PRODUCTS_MICROSERVICE_PORT</span>: joi.number().required(),
})
.unknown(<span class="hljs-literal">true</span>);

<span class="hljs-keyword">const</span> { error, value } = envsSchema.validate( process.env );


<span class="hljs-keyword">if</span> ( error ) {
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Config validation error: <span class="hljs-subst">${ error.message }</span>`</span>);
}

<span class="hljs-keyword">const</span> envVars:EnvVars = value;


<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> envs = {
  <span class="hljs-attr">port</span>: envVars.PORT,

  <span class="hljs-attr">productsMicroserviceHost</span>: envVars.PRODUCTS_MICROSERVICE_HOST,
  <span class="hljs-attr">productsMicroservicePort</span>: envVars.PRODUCTS_MICROSERVICE_PORT,
};
</div></code></pre>
<ul>
<li>También creo el archivo /config/services.ts con el token de inyección</li>
<li>Lo coloco en el archivo de barril</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> PRODUCT_SERVICE = <span class="hljs-string">'PRODUCT_SERVICE'</span>;
</div></code></pre>
<ul>
<li>En orders-microservice.service necesito hacer la inyección usando <strong>@Inject</strong> pasándole el token de inyección <strong>PRODUCT_SERVICE</strong></li>
<li>Constructores de clases derivadas (herencia) deben llamar a <strong>super</strong></li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> {
  HttpStatus,
  Inject,
  Injectable,
  Logger,
  OnModuleInit,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { CreateOrderDto } <span class="hljs-keyword">from</span> <span class="hljs-string">'./dto/create-order.dto'</span>;
<span class="hljs-keyword">import</span> { PrismaClient } <span class="hljs-keyword">from</span> <span class="hljs-string">'@prisma/client'</span>;
<span class="hljs-keyword">import</span> { ClientProxy, RpcException } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/microservices'</span>;
<span class="hljs-keyword">import</span> { OrderPaginationDto } <span class="hljs-keyword">from</span> <span class="hljs-string">'./dto/order-pagination.dto'</span>;
<span class="hljs-keyword">import</span> { ChangeOrderStatusDto } <span class="hljs-keyword">from</span> <span class="hljs-string">'./dto'</span>;
<span class="hljs-keyword">import</span> { PRODUCT_SERVICE } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/config'</span>;
<span class="hljs-keyword">import</span> { firstValueFrom, throwError } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;

@Injectable()
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrdersService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PrismaClient</span> <span class="hljs-title">implements</span> <span class="hljs-title">OnModuleInit</span> </span>{
  private readonly logger = <span class="hljs-keyword">new</span> Logger(<span class="hljs-string">'OrdersService'</span>);

  <span class="hljs-keyword">constructor</span>(
    @Inject(PRODUCT_SERVICE) private readonly productsClient: ClientProxy,
  ) {
    <span class="hljs-keyword">super</span>(); <span class="hljs-comment">//llamo a super</span>
  }

  <span class="hljs-keyword">async</span> onModuleInit() {
    <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.$connect();
    <span class="hljs-keyword">this</span>.logger.log(<span class="hljs-string">'Database connected'</span>);
  }
}
</div></code></pre>
<ul>
<li>Estoy en orders-microservice.service</li>
<li>Con el método create necesito llegar a products con .send si quiero trabajarlo como un Observable</li>
<li>Si quiero trabajarlo con una <strong>promesa</strong> debo usar <strong>firstValueFrom</strong></li>
<li>Coloco todo dentro de un try catch</li>
<li>Con .map extraigo el arreglo de ids del dto</li>
<li>Uso el await con firstValueFrom, como parámetro le paso el .send usando el productsClient (el servicio inyectado de PRODUCTS_SERVICE)
<ul>
<li>Para comunicarme con el método validateProducts le paso en el objeto el cmd con el string validate_products (del MessagePattern) y el arreglo de ids que he sacado haciendo un map del dto.id</li>
</ul>
</li>
<li>Para calcular el total a pagar hago uso del reducer
<ul>
<li>acc es el acumulador. Uso el createOrderDto porque es donde están las orders con los items (y el precio)</li>
<li>Uso el arreglo de products para encontrar los productos que coincidan con los ids de cada orderItem y obtener el precio</li>
<li>Retorno el precio * la cantidad en cada orderItem</li>
<li>El acumulador empieza en 0</li>
</ul>
</li>
<li>Uso un reducer también para el total de items
<ul>
<li>Sumo el acumulador a la cantidad de items por orden</li>
</ul>
</li>
<li>Para crear la orden necesito insertar la orden y los items, ambas inserciones deben ser exitosas</li>
<li>Esto suele hacerse con una <strong>.$transaction</strong> porque si una falla tengo que hacer un rollback</li>
<li>Vamos a crearlo todo en una sola orden</li>
<li><em>NOTA</em>: el reducer va acumulando en el acumulador el numero de iteraciones y los guarda en acc.
<ul>
<li>El segundo parámetro del callback es el objeto que voy a iterar. El 0 es el valor inicial del acumulador</li>
<li>Por ejemplo:</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> reducidor = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>].reduce(<span class="hljs-function">(<span class="hljs-params">acc, el</span>)=&gt;</span> acc + el, <span class="hljs-number">0</span>)
<span class="hljs-built_in">console</span>.log(reducidor) <span class="hljs-comment">//Esto devuelve 15</span>

<span class="hljs-comment">//En la primera iteracion acc vale 0 y el vale 1, 0+1 == 1</span>
<span class="hljs-comment">//En la segunda acc vale 1 y el 2, 1+2 == 3</span>
<span class="hljs-comment">//En la tercera acc vale 3 y el 3 == 6</span>
<span class="hljs-comment">//En la cuarta acc vale 6 y el 4 == 10</span>
<span class="hljs-comment">//en la quinta acc vale 10 y el 5 == 15 </span>
</div></code></pre>
<pre class="hljs"><code><div> <span class="hljs-keyword">async</span> create(createOrderDto: CreateOrderDto) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">//1 Confirmar los ids de los productos</span>
      <span class="hljs-keyword">const</span> productIds = createOrderDto.items.map(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item.productId); <span class="hljs-comment">//extraigo los ids en un arreglo</span>


      <span class="hljs-comment">//llamo al microservicio para validar que existan los productos</span>
      <span class="hljs-keyword">const</span> products: any[] = <span class="hljs-keyword">await</span> firstValueFrom(
        <span class="hljs-keyword">this</span>.productsClient.send({ <span class="hljs-attr">cmd</span>: <span class="hljs-string">'validate_products'</span> }, productIds),
      );

      <span class="hljs-comment">//2. Cálculos de los valores                           //en orderItem tengo el precio</span>
      <span class="hljs-keyword">const</span> totalAmount = createOrderDto.items.reduce(<span class="hljs-function">(<span class="hljs-params">acc, orderItem</span>) =&gt;</span> {

        <span class="hljs-comment">//necesito encontrar orderItem dentro del arreglo de productos</span>
        <span class="hljs-comment">//no quiero confiar en el precio del dto, por eso uso el de los productos través del id</span>
        <span class="hljs-keyword">const</span> price = products.find(
          <span class="hljs-function">(<span class="hljs-params">product</span>) =&gt;</span> product.id === orderItem.productId).price;
        <span class="hljs-keyword">return</span> price * orderItem.quantity + acc;
      }, <span class="hljs-number">0</span>);

      <span class="hljs-keyword">const</span> totalItems = createOrderDto.items.reduce(<span class="hljs-function">(<span class="hljs-params">acc, orderItem</span>) =&gt;</span> {
        <span class="hljs-keyword">return</span> acc + orderItem.quantity; <span class="hljs-comment">//Si tengo x cantidad, necesito contarlo por cada uno de los elementos del arreglo</span>
      }, <span class="hljs-number">0</span>); <span class="hljs-comment">//Para la suma de todos los elementos de un arreglo, ene el acc voy guardando la suma de las iteraciones</span>

      <span class="hljs-comment">//3. Crear una transacción de base de datos</span>
      <span class="hljs-keyword">const</span> order = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.order.create({
        <span class="hljs-attr">data</span>: {
          <span class="hljs-attr">totalAmount</span>: totalAmount,
          <span class="hljs-attr">totalItems</span>: totalItems,
          <span class="hljs-attr">OrderItem</span>: {
            <span class="hljs-attr">createMany</span>: {  <span class="hljs-comment">//uso createMany</span>
              <span class="hljs-attr">data</span>: createOrderDto.items.map(<span class="hljs-function">(<span class="hljs-params">orderItem</span>) =&gt;</span> ({
                <span class="hljs-attr">price</span>: products.find(  <span class="hljs-comment">//no puedo tomar directamente el orderItems.price porque no lo hemos validado, no sabemos si es el correcto</span>
                  <span class="hljs-function">(<span class="hljs-params">product</span>) =&gt;</span> product.id === orderItem.productId, <span class="hljs-comment">//uso los precios del arreglo de products que viene de la tabla de Products</span>
                ).price,
                <span class="hljs-attr">productId</span>: orderItem.productId,
                <span class="hljs-attr">quantity</span>: orderItem.quantity,
              })),
            },
          },
        },
        <span class="hljs-comment">//que incluya el OrderItem. Si pongo solo OrderItem: true me devuelve todo</span>
        <span class="hljs-attr">include</span>: {
          <span class="hljs-attr">OrderItem</span>: {
            <span class="hljs-attr">select</span>: { <span class="hljs-comment">//puedo seleccionar los campos que quiero devolver</span>
              <span class="hljs-attr">price</span>: <span class="hljs-literal">true</span>,
              <span class="hljs-attr">quantity</span>: <span class="hljs-literal">true</span>,
              <span class="hljs-attr">productId</span>: <span class="hljs-literal">true</span>,
            },
          },
        },
      });

      <span class="hljs-keyword">return</span> {
        ...order, <span class="hljs-comment">//me quedo con todo lo de order menos OrderItem, qdel que me aseguro que el nombre coincida con la tabla de products</span>
        <span class="hljs-attr">OrderItem</span>: order.OrderItem.map(<span class="hljs-function">(<span class="hljs-params">orderItem</span>) =&gt;</span> ({
          ...orderItem, <span class="hljs-comment">//me quedo con todo de orderItem, agrego el nombre de la tabla de Products desde el arreglo de products</span>
          <span class="hljs-attr">name</span>: products.find(<span class="hljs-function">(<span class="hljs-params">product</span>) =&gt;</span> product.id === orderItem.productId).name,
        })),
      };
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException({
        <span class="hljs-attr">status</span>: HttpStatus.BAD_REQUEST,
        <span class="hljs-attr">message</span>: <span class="hljs-string">'Check logs'</span>,
      });
    }
  }
</div></code></pre>
<ul>
<li>De hecho, podríamos ignorar el precio en OrderItem porque lo vamos a usar de Products</li>
<li>En findOrderById quiero que aparezca el detalle</li>
</ul>
<hr>
<h2 id="buscar-order-por-id-con-su-detalle">Buscar order por Id con su detalle</h2>
<ul>
<li>Quiero saber el detalle de esa orden y los ids de los productos</li>
<li>Uso el include para retornar el OrderItem con los campos indicados en el select</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-keyword">async</span> findOne(id: string) {
    <span class="hljs-keyword">const</span> order = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.order.findFirst({
      <span class="hljs-attr">where</span>: { id },
      <span class="hljs-attr">include</span>: {
        <span class="hljs-attr">OrderItem</span>: {
          <span class="hljs-attr">select</span>: {
            <span class="hljs-attr">price</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">quantity</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">productId</span>: <span class="hljs-literal">true</span>,
          },
        },
      },
    });

    <span class="hljs-keyword">if</span> (!order) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException({
        <span class="hljs-attr">status</span>: HttpStatus.NOT_FOUND,
        <span class="hljs-attr">message</span>: <span class="hljs-string">`Order with id <span class="hljs-subst">${id}</span> not found`</span>,
      });
    }
    <span class="hljs-keyword">const</span> productIds = order.OrderItem.map(<span class="hljs-function">(<span class="hljs-params">orderItem</span>) =&gt;</span> orderItem.productId); <span class="hljs-comment">//extraigo los ids, un arreglo de números</span>
    
    <span class="hljs-comment">//valido comunicándome con el microservicio de products que los products existan</span>
    <span class="hljs-comment">//ESTO EN ESTE MOMENTO NO DEBERÍA FALLAR</span>
    <span class="hljs-keyword">const</span> products: any[] = <span class="hljs-keyword">await</span> firstValueFrom(
      <span class="hljs-keyword">this</span>.productsClient.send({ <span class="hljs-attr">cmd</span>: <span class="hljs-string">'validate_products'</span> }, productIds),
    );

    <span class="hljs-keyword">return</span> {
      ...order, <span class="hljs-comment">//retorno la order y trabajo con OrderItem</span>
      <span class="hljs-attr">OrderItem</span>: order.OrderItem.map(<span class="hljs-function">(<span class="hljs-params">orderItem</span>) =&gt;</span> ({
        ...orderItem, <span class="hljs-comment">//retorno orderItem y del arreglo de products validado obtengo el nombre</span>
        <span class="hljs-attr">name</span>: products.find(<span class="hljs-function">(<span class="hljs-params">product</span>) =&gt;</span> product.id === orderItem.productId)
          .name,
      })),
    };
  }
</div></code></pre>
<hr>
<h2 id="problemas-y-soluciones">Problemas y soluciones</h2>
<ul>
<li>Esto, organizado así, es muy probable que se salga de control</li>
<li>Orders está conectado directamente con Products</li>
<li>En algún momento (cuando implementemos autenticación) orders va a tener que validar un token con el microservicio de auth</li>
<li>Habría que conectar orders con auth, implica cambios, el cliente-gateway, etc</li>
<li>Esto va a crear un anidamiento dificil de leer y gestionar</li>
<li>La solución pasa por un <strong>SERVICE BROKER</strong>, un middleman que se encargue de procesar ese montón de paquetes y pedidos entre los microservicios</li>
<li><strong>RabbitM</strong>Q es muy popular. Se crea una cola de procesos y mensajería, es cómo una oficina postal que se va a dedicar a mandar las cartas a los destinatarios, eso queda en el file system y hasta que el destinatario lo confirma no se borra de la cola</li>
<li>También se puede, basado en alguna transacción o evento que suceda, notificar a dos o tres microservicios de manera simultanea</li>
<li>Por ejemplo, si alguien paga una orden: yo quiero notificar a orders que la orden fue pagada, quiero notificar al cliente que el pago se recibió. Son dos cosas independientes relacionadas a microservicios distintos que reaccionan ante un mismo evento</li>
<li>COn la arquitectura actual, significaría que desde el microservicio de pagos llamar al microservicio de notificaciones y esto sería ineficiente, significa acoplamiento, y si las notificaciones se caen fallan podría hacer fallar el servicio de pagos porque esa parte nos va a fallar</li>
<li>Podemos mandar un evento desde orders a notificaciones y si lo recibe bien y si no también, pero no tiene mucho sentido</li>
<li>Por todo esto vamos a implementar una arquitectura diferente, con un servidor de <strong>NATS</strong> que estará en medio del cliente-gateway y mis microservicios</li>
<li>Vamos a centralizar la comunicación entre microservicios</li>
<li>NATS server se va a encargar de <strong>notificar a todos los microservicios que les interese un mensaje</strong></li>
<li>Esto va a <strong>eliminar la comunicación directa entre microservicios</strong></li>
<li>NATS va a crear unos <strong>TOPICS</strong> y estos se notificarán a mis microservicios
<ul>
<li>Cuando se cree una orden, NATS se lo notificará al cliente-gateway</li>
<li>Como el cliente-gateway está suscrito a la respuesta de la creación de la orden, va a notificar al cliente</li>
</ul>
</li>
<li>En la práctica es más fácil trabajar con este servidor de NATS!</li>
</ul>
<hr>
<h1 id="05--nest-microservicios---nats">05- NEST MICROSERVICIOS - NATS</h1>
<h2 id="problema--soluci%C3%B3n">Problema / Solución</h2>
<ul>
<li>La orden se crea con el detalle, están fuertemente acopladas, las hicimos en el mismo microservicio</li>
<li>Orders se comunica directamente con Products para confirmar los productos</li>
<li>Con la arquitectura actual, cuando añadamos autenticación y queramos modificar una orden, vamos a tener que añadir otra dependencia a ordenes (el microservicio de auth)
En lugar de eso, nos encargaremos de hacer las comunicaciones mediante un Service Broker, un middleman situado entre el cliente-gateaway y mis microservicios</li>
<li>Cuando NATS recibe la solicitud de creación de una orden desde el cliente-gateway mandada por el cliente, orders que está suscrita al tópico de creación de la orden dará una respuesta</li>
<li>Orders necesita saber si los ids de los productos que lleva el detalle existen en la db de productos</li>
<li>El servidor de NATS servirá de intermediario entre orders-microservice y productws-microservice</li>
<li>Bueno, esto es una forma simplificada de lo que ocurre</li>
<li><strong>NATS BROKER</strong>
<ul>
<li>Es open source, ligero y facil de configurar</li>
<li>Comunicará mis microservicios (estos pueden mantener interconexiones sin necesidad de pasar por NATS)</li>
<li>NATS se encarga de hacer balanceo de carga
<ul>
<li>Es decir, si tengo varios microservicios y creo que todos respondan al mismo tiempo se puede configurar con NATS</li>
<li>Cuando implementemos los microservicios de pagos y notificaciones vamos a querer hacer uso de esto</li>
</ul>
</li>
<li>Trabaja con mensajería tipo <strong>publicar y suscribir</strong></li>
<li>Hay temas <strong>topics/subjects</strong> a los cuales <strong>se escucha</strong></li>
<li>Puedes tener <strong>múltiples escuchas (listeners)</strong> al mismo topic</li>
<li>Pensado para <strong>escalamiento horizontal</strong></li>
<li>Seguridad, balanceo de carga inlcuido</li>
<li><strong>Payload agnóstico</strong>, pueden ser strings, numeros, lo que sea necesario</li>
<li>Rápido y eficiente, y open source</li>
</ul>
</li>
<li>Por ejemplo, una vez realizado un pago voy a querer comunicarme con tres microservicios de manera instantánea
<ul>
<li>Con auth, email notification y ordenes</li>
</ul>
</li>
<li>Con la arquitectura que hemos implementado hasta ahora se convertirían en dependencias del microservicio de pagos</li>
<li>Crearemos una <strong>Docker Network</strong> para tenerlo todo en un mismo lado y que solo mediante el puerto 3000 a través de una API REST se acceda a esta red interna</li>
<li>Primero vamos a establecer la arquitectura con NATS y luego crearemos la Docker Network</li>
</ul>
<hr>
<h2 id=""></h2>
<ul>
<li>En orders-microservice debo ejecutar docker compose up -d para levantar el microservicio con Docker corriendo</li>
<li>Si aparece el error de prisma usar <strong>npx prisma generate</strong></li>
<li>Para que no haya que instalar NATS físicamente en el host usaremos Docker</li>
<li>Para levantar el servidor de NATS usar
<ul>
<li>4222: Nuestros microservicios van a estar hablando con NATS por este puerto</li>
<li>8222: ofrece una comunicación HTTP para monitorear los clientes y ver quien se conecta, quien se cae, se levanta, etc</li>
<li>6222: Puerto utilizado para el clustering. En estecaso no lo usaremos</li>
<li>nats al final esla imagen de nats:latest por defecto</li>
<li>Le llamaremos nats-sever</li>
</ul>
</li>
</ul>
<blockquote>
<p>docker run -d --name nats-server -p 4222:4222 -p 8222:8222 nats
npm run start:dev</p>
</blockquote>
<ul>
<li>En .env de orders tengo</li>
</ul>
<pre class="hljs"><code><div>PORT=3002

PRODUCTS_MICROSERVICE_HOST=localhost
PRODUCTS_MICROSERVICE_PORT=3001

DATABASE_URL=&quot;postgresql://postgres:123456@localhost:5434/ordersdb?schema=public&quot;

# NATS_SERVERS=&quot;nats://localhost:4222,nats://localhost:4223&quot;
NATS_SERVERS=&quot;nats://localhost:4222&quot;
</div></code></pre>
<ul>
<li>En .env de products tengo</li>
<li>El :4223 no existe. Servirá luego parahacer las pruebas de validación de las variables de entorno, donde validaremos que sea un array y separaremos por comas los strings para porder validarlos</li>
</ul>
<pre class="hljs"><code><div>PORT=3001

DATABASE_URL=&quot;file:./dev.db&quot;


NATS_SERVERS=&quot;nats://localhost:4222,nats://localhost:4223&quot;
</div></code></pre>
<ul>
<li>En .env de cliente-gateway tengo</li>
</ul>
<pre class="hljs"><code><div>PORT=3000


# PRODUCTS_MICROSERVICE_HOST=localhost
# PRODUCTS_MICROSERVICE_PORT=3001

# ORDERS_MICROSERVICE_HOST=localhost
# ORDERS_MICROSERVICE_PORT=3002


# NATS_SERVERS=&quot;nats://localhost:4222,nats://localhost:4223&quot;
NATS_SERVERS=&quot;nats://localhost:4222&quot;
</div></code></pre>
<ul>
<li>Una vez ya ha descargado la imagen de Docker, para iniciar el microservicio usar el mismo prompt sin el --name</li>
<li>Con crear la conexión con NATS en orders es suficiente</li>
</ul>
<blockquote>
<p>docker run -d -p 4222:4222 -p 8222:8222 nats
npm run start:dev</p>
</blockquote>
<ul>
<li>
<p>En localhost:8222 puedo monitorear el NATS (tiene una interfaz gráfica)</p>
</li>
<li>
<p><strong>RESUMEN</strong>:</p>
<ul>
<li>uso el comando de docker run con el nombre del nats-server y los puertos + la imagen para que descargue la imagen de NATS si no la tengo</li>
</ul>
</li>
</ul>
<hr>
<h2 id="products-microservice---cambiar-de-tcp-a-nats">Products-microservice  - Cambiar de TCP a NATS</h2>
<ul>
<li>Para trabajar con nats en NEST debo instalar nats con npm i nats</li>
<li>Es muy similar a la conexión con TCP, solo que en lugar de los puertos tengo en options un arreglo con los servidores (puede ser uno, pueden ser más)</li>
<li>Debo añadir la variable de entorno a envs.ts</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> <span class="hljs-string">'dotenv/config'</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> joi <span class="hljs-keyword">from</span> <span class="hljs-string">'joi'</span>;

interface EnvVars {
  <span class="hljs-attr">PORT</span>: number;
  DATABASE_URL: string;

  NATS_SERVERS: string[]; <span class="hljs-comment">//añado el string del NATS</span>
}

<span class="hljs-keyword">const</span> envsSchema = joi.object({
  <span class="hljs-attr">PORT</span>: joi.number().required(),
  <span class="hljs-attr">DATABASE_URL</span>: joi.string().required(),
                                                              <span class="hljs-comment">//en este momento todavía no es un arreglo, pero hago la validación</span>
  <span class="hljs-attr">NATS_SERVERS</span>: joi.array().items( joi.string() ).required(), <span class="hljs-comment">//valido que el NATS sea un array y que contenga un string ( yque sea obligatorio)</span>
})
.unknown(<span class="hljs-literal">true</span>);

<span class="hljs-keyword">const</span> { error, value } = envsSchema.validate({ 
  ...process.env,         <span class="hljs-comment">//hago que sea un arreglo con .split                           </span>
  <span class="hljs-attr">NATS_SERVERS</span>: process.env.NATS_SERVERS?.split(<span class="hljs-string">','</span>) <span class="hljs-comment">//si tengo varios strings, los separo por la coma para validarlos</span>
});

<span class="hljs-comment">//explicación: ES AL APLICAR SPLIT QUE DEVUELVE UN ARREGLO</span>

<span class="hljs-keyword">const</span> loquesea =<span class="hljs-string">"loalaoaoala, pwepejdoiejhd"</span>

<span class="hljs-keyword">const</span> arrayLoquesea = loquesea.split(<span class="hljs-string">','</span>)

<span class="hljs-built_in">console</span>.log(arrayLoquesea) <span class="hljs-comment">//["loalaoaoala", " pwepejdoiejhd"]</span>


<span class="hljs-keyword">if</span> ( error ) {
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Config validation error: <span class="hljs-subst">${ error.message }</span>`</span>);
}

<span class="hljs-keyword">const</span> envVars:EnvVars = value;


<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> envs = {
  <span class="hljs-attr">port</span>: envVars.PORT,
  <span class="hljs-attr">databaseUrl</span>: envVars.DATABASE_URL,

  <span class="hljs-attr">natsServers</span>: envVars.NATS_SERVERS, <span class="hljs-comment">//exporto la variable</span>
}
</div></code></pre>
<ul>
<li>En el main</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { NestFactory } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/core'</span>;
<span class="hljs-keyword">import</span> { AppModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.module'</span>;
<span class="hljs-keyword">import</span> { Logger, ValidationPipe } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { envs } <span class="hljs-keyword">from</span> <span class="hljs-string">'./config'</span>;
<span class="hljs-keyword">import</span> { MicroserviceOptions, Transport } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/microservices'</span>;

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bootstrap</span>(<span class="hljs-params"></span>) </span>{

  <span class="hljs-keyword">const</span> logger = <span class="hljs-keyword">new</span> Logger(<span class="hljs-string">'Main'</span>);

  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">await</span> NestFactory.createMicroservice&lt;MicroserviceOptions&gt;(
    AppModule,
    {
      <span class="hljs-attr">transport</span>: Transport.NATS,
      <span class="hljs-attr">options</span>: {
        <span class="hljs-attr">servers</span>: envs.natsServers <span class="hljs-comment">//'nats://localhost:4222, nats://localhosts:4223'</span>
      }
    }
  );

  app.useGlobalPipes(
    <span class="hljs-keyword">new</span> ValidationPipe({
      <span class="hljs-attr">whitelist</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">forbidNonWhitelisted</span>: <span class="hljs-literal">true</span>,
    }),
  );

  <span class="hljs-keyword">await</span> app.listen();
  logger.log(<span class="hljs-string">`Products Microservice running on port <span class="hljs-subst">${ envs.port }</span>`</span>);

}
bootstrap();
</div></code></pre>
<ul>
<li>Puedo seguir usando el <strong>MessagePattern</strong>, puedo usar comodines</li>
</ul>
<pre class="hljs"><code><div>@MessagePattern(<span class="hljs-string">'time.*'</span>) <span class="hljs-comment">//escuchará cualquier mensaje que venga de time</span>
getDate(@Payload() data: number[], @Ctx() context: NatsContext){
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Subject: <span class="hljs-subst">${context.getSubject()}</span>`</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toLocaleString(...)
}
</div></code></pre>
<ul>
<li>Para poder ver los productos debemos cambiar tambien el canal de comunicación en cliente-gateway</li>
<li><strong>RESUMEN</strong>: instalo nats, configuro y valido la variable de entorno, me aseguro de que sea un arreglo, coloco la variable en el main y cambio el transporte</li>
</ul>
<hr>
<h2 id="cliente-gateway---cambiar-tcp-a-nats">Cliente-gateway - Cambiar TCP a NATS</h2>
<ul>
<li>Debemos instalar nats tambien con npm i nats</li>
<li>Vamos a crear un módulo centralizado para poder importar la comunicación</li>
<li>Podemos hacer el cambio en cliente-gateway.products.module de esta forma</li>
</ul>
<pre class="hljs"><code><div>imports:[
    ClientsModule.register([
    {
      <span class="hljs-attr">name</span>: NATS_SERVICE,
      <span class="hljs-attr">transport</span>: Transport.NATS,
      <span class="hljs-attr">options</span>: {
        <span class="hljs-attr">servers</span>: envs.natsServers,
      },
    },
  ])
]
</div></code></pre>
<ul>
<li>Pero podemos crear un módulo que podamos copiar y pegar a los otros clientes (orders, en este caso)</li>
<li>Creo la carpeta en cliente-gateway/src/products/transports/nats.module.ts</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Module } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { ClientsModule, Transport } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/microservices'</span>;
<span class="hljs-keyword">import</span> { NATS_SERVICE, envs } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/config'</span>;

@Module({
  <span class="hljs-attr">imports</span>: [
    ClientsModule.register([
      {
        <span class="hljs-attr">name</span>: NATS_SERVICE,
        <span class="hljs-attr">transport</span>: Transport.NATS,
        <span class="hljs-attr">options</span>: {
          <span class="hljs-attr">servers</span>: envs.natsServers,
        },
      },
    ]),
  ],
  <span class="hljs-attr">exports</span>: [
    ClientsModule.register([
      {
        <span class="hljs-attr">name</span>: NATS_SERVICE,
        <span class="hljs-attr">transport</span>: Transport.NATS,
        <span class="hljs-attr">options</span>: {
          <span class="hljs-attr">servers</span>: envs.natsServers,
        },
      },
    ]),
  ],
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NatsModule</span> </span>{}
</div></code></pre>
<ul>
<li>El token de inyección NATS_SERVICE está alojado en cliente-gateway/src/config/services.ts</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> PRODUCT_SERVICE = <span class="hljs-string">'PRODUCT_SERVICE'</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> ORDER_SERVICE = <span class="hljs-string">'ORDER_SERVICE'</span>;


<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> NATS_SERVICE = <span class="hljs-string">'NATS_SERVICE'</span>;
</div></code></pre>
<ul>
<li>Importo el módulo en cliente-gateway.app.module</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Module } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { ProductsModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'./products/products.module'</span>;
<span class="hljs-keyword">import</span> { OrdersModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'./orders/orders.module'</span>;
<span class="hljs-keyword">import</span> { NatsModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'./transports/nats.module'</span>;


@Module({
  <span class="hljs-attr">imports</span>: [ProductsModule, OrdersModule, NatsModule],
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppModule</span> </span>{}
</div></code></pre>
<ul>
<li>Y también en cliente-gateway.products.module</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Module } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { ProductsController } <span class="hljs-keyword">from</span> <span class="hljs-string">'./products.controller'</span>;
<span class="hljs-keyword">import</span> { NatsModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/transports/nats.module'</span>;

@Module({
  <span class="hljs-attr">controllers</span>: [ProductsController],
  <span class="hljs-attr">providers</span>: [],
  <span class="hljs-attr">imports</span>: [NatsModule],
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductsModule</span> </span>{}
</div></code></pre>
<ul>
<li>Hago lo mismo en orders! copio la carpeta transports y hago la importación del módulo</li>
<li>Para usarlo en el controller de cliente-gateway.products.controller debo inyectarlo con el token de inyección y usar CLientProxy nuevamente</li>
<li>ya no lo nombro productsClient, simplemente <strong>client</strong></li>
<li>cliente-gateway.products.controller</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { ClientProxy, RpcException } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/microservices'</span>;
<span class="hljs-keyword">import</span> { catchError, firstValueFrom } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;
<span class="hljs-keyword">import</span> { PaginationDto } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/common'</span>;
<span class="hljs-keyword">import</span> { NATS_SERVICE } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/config'</span>;
<span class="hljs-keyword">import</span> { CreateProductDto } <span class="hljs-keyword">from</span> <span class="hljs-string">'./dto/create-product.dto'</span>;
<span class="hljs-keyword">import</span> { UpdateProductDto } <span class="hljs-keyword">from</span> <span class="hljs-string">'./dto/update-product.dto'</span>;

@Controller(<span class="hljs-string">'products'</span>)
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductsController</span> </span>{
  <span class="hljs-keyword">constructor</span>(
    @Inject(NATS_SERVICE) private readonly client: ClientProxy, //inyecto el token y uso Clientproxy
  ) {}

  @Post()
  createProduct(@Body() createProductDto: CreateProductDto) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.client.send(
      { <span class="hljs-attr">cmd</span>: <span class="hljs-string">'create_product'</span> },
      createProductDto,
    );
  }
}
</div></code></pre>
<ul>
<li>Lo mismo en el módulo de orders de cliente-gateway</li>
<li>Tengo que hacer la misma configuración en orders-microservice, copiar el modulo transports, importarlo, validar la variable de entorno, inyectar el token en el controlador, renombrar el servicio a client...</li>
</ul>
<hr>
<h2 id="docker-network---problema-y-necesidad">Docker Network - problema y necesidad</h2>
<ul>
<li>Tenemos varias terminales corriendo, el Docker, tenemos que levantar el NATS....</li>
<li>Un poco complicado (y tedioso de levantar y subir) para alguien que venga de fuera desarrollar así</li>
<li>Crearemos una red que se encargue de comunicarse con mis servidores, que mediante un solo comando levante toda la infraestructura</li>
<li>Puedo hacer que no se levanten los microservicios si NATS no está arriba</li>
<li>Lo mismo con la DB, si no está arriba el microservicio no se va a levantar</li>
<li>Crearemos un monorepo. No es más que un repositorio que tiene varios repositorios de nuestra app</li>
<li>Nest ofrece una manera un poco acoplada</li>
<li>Usaremos otra metodología</li>
</ul>
<hr>
<h1 id="nest-microservicios---launcher-docker">NEST MICROSERVICIOS - LAUNCHER (DOCKER)</h1>
<ul>
<li>Un comando para levantar todo y tenerlo todo en una terminal</li>
<li>Es bastante común trabajar con monorepos que contienen referencias a otros repositorios</li>
</ul>
<hr>
<h2 id="crear-red-y-levantar-todo-con-un-solo-comando">Crear red y levantar todo con un solo comando</h2>
<ul>
<li>En mi código no habrá la relación con los submódulos para conectar con los microservicios, pero si dejaré la documentación aquí</li>
<li>Creo el docker-compose.yml en la raíz del launcher</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-attr">version:</span> <span class="hljs-string">'3'</span>


<span class="hljs-attr">services:</span>

  <span class="hljs-comment"># levanto el nats</span>
  <span class="hljs-attr">nats-server:</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">nats:latest</span> <span class="hljs-comment"># descargo la última verisión de la imagen de nats</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">"8222:8222"</span> <span class="hljs-comment"># el 8222 es el puerto por defecto junto al 4222, mirar la docu</span>
                    <span class="hljs-comment"># exponer estos puertos es para que el mundo exterior pueda llegar a NATS, no la red interna</span>
                    <span class="hljs-comment"># 8222 me ofrece el servicio de poder monitorear quien se conecta, etc</span>
                    <span class="hljs-comment"># por lo que estaría exponiendo el puerto en la zona externa entre el cliente y el gateway</span>
                    <span class="hljs-comment"># en la vida real podría quitarlo, no necesito exponerlo</span>

  <span class="hljs-attr">client-gateway:</span> <span class="hljs-comment">#nombro mi servicio, necesito crear una imagen para montarla en un contenedor</span>
    <span class="hljs-attr">build:</span> <span class="hljs-string">./client-gateway</span> <span class="hljs-comment"># vendrá a esta ruta a buscar el dockerfile</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">${CLIENT_GATEWAY_PORT}:3000</span> <span class="hljs-comment">#comunico el puerto de mi computadora con el del contenedor</span>
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">./client-gateway/src:/usr/src/app/src</span> <span class="hljs-comment">#puedo enfocarme solo en el src, lo mapeo a usr/src/app/src (node tiene este path)</span>
    <span class="hljs-attr">command:</span> <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">start:dev</span>
    <span class="hljs-attr">environment:</span> <span class="hljs-comment"># definimos las variables de entorno (es como tener mi .env aqui, las validaciones que hice aplican aqui)</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">PORT=3000</span> 
      <span class="hljs-bullet">-</span> <span class="hljs-string">NATS_SERVERS=nats://nats-server:4222</span> <span class="hljs-comment"># coloco nats-server en lugar de localhost porque asi se llama el servicio y le pone nombre al contenedor</span>

  <span class="hljs-attr">products-ms:</span> <span class="hljs-comment"># este es el nombre del server(imagen de Docker)</span>
    <span class="hljs-attr">build:</span> <span class="hljs-string">./products-ms</span>
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">./products-ms/src:/usr/src/app/src</span> <span class="hljs-comment"># mapeo el src</span>
    <span class="hljs-attr">command:</span> <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">start:dev</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">PORT=3001</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">NATS_SERVERS=nats://nats-server:4222</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">DATABASE_URL=file:./dev.db</span> <span class="hljs-comment"># products está en el filesystem porque uso SQLite</span>

  
  <span class="hljs-comment"># Orders MS</span>
  <span class="hljs-attr">orders-ms:</span>
    <span class="hljs-attr">depends_on:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">orders-db</span> <span class="hljs-comment">#este microservicio no se debe levantar hasta que orders-db se levante (levantar, no construir)</span>
    <span class="hljs-attr">build:</span> <span class="hljs-string">./orders-ms</span>
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">./orders-ms/src:/usr/src/app/src</span>
    <span class="hljs-attr">command:</span> <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">start:dev</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">PORT=3002</span>                                  <span class="hljs-comment"># apuntando a docker, no tengo localhost, tego orders-db (así llamé al servicio)</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">DATABASE_URL=postgresql://postgres:123456@orders-db:5432/ordersdb?schema=public</span> <span class="hljs-comment"># lo conecto al puerto de la imagen</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">NATS_SERVERS=nats://nats-server:4222</span>



  <span class="hljs-comment"># Orders DB     también descargoi la imagen de postgres!!</span>
  <span class="hljs-attr">orders-db:</span>
    <span class="hljs-attr">container_name:</span> <span class="hljs-string">orders_database</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">postgres:16.2</span>
    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">./orders-ms/postgres:/var/lib/postgresql/data</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-number">5434</span><span class="hljs-string">:5432</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">POSTGRES_USER=postgres</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">POSTGRES_PASSWORD=123456</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">POSTGRES_DB=ordersdb</span>

</div></code></pre>
<ul>
<li>No se recomienda usar el tag :latest porque luego se despliega y se hacen versiones incompatibles. No hacer en producción (se suben manualmente)</li>
<li>NATS ya está dentro de la red, detrás del Gateway que comunica con el exterior</li>
<li>La idea de exponer los puertos 4222, 8222 es para que el mundo exterior pueda llegar a ellos, no la red interna</li>
<li>El puerto que me interesa es el 8222 porque me facilita el servicio para la monitorización de NATS desde el navegador</li>
<li>El nombre del servidor es exactamente igual al nombre del servicio donde levanto la imagen de NATS en el archivo de docker</li>
<li>En lugar de localhost en el string de conexión, pondré nats-server, lo mismo en las variables de entorno del .ym en environment</li>
<li>Para la DATABASE_URL En el caso de products coloco el archivo del filesystem de la carpeta de prisma</li>
<li>Para postgres la dirección de la imagen de Docker</li>
<li>Empezando por el client-gateway, voy a necesitar configurar el dockerfile en la raíz</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">FROM</span> node:<span class="hljs-number">20</span>-alpine3.<span class="hljs-number">19</span> /*tomo la imagen de NODE*/

<span class="hljs-keyword">WORKDIR</span><span class="bash"> /usr/src/app    /*desde aqui trabajaremos, es donde colocaremos la app*/</span>

<span class="hljs-keyword">COPY</span><span class="bash"> package.json ./    /*copiamos el json*/</span>
<span class="hljs-keyword">COPY</span><span class="bash"> package-lock.json ./</span>


<span class="hljs-keyword">RUN</span><span class="bash"> npm install          /*instalamos las dependencias porque en mi maquina tengo un linux, no son las mismas*/</span>

<span class="hljs-keyword">COPY</span><span class="bash"> . .                 /*copiamos todo lo que no está ignorado en el dockerignore*/</span>

<span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">3000</span>              /*expongo el puerto de client-gateway*/
</div></code></pre>
<ul>
<li>Creo el .dockerignore ( es el mismo para prodcuts y orders)</li>
</ul>
<pre class="hljs"><code><div>dist/

node_modules/

.env

.vscode/
</div></code></pre>
<ul>
<li>Debo crear el dockerfile en products y orders</li>
<li>En products dockerfile llamo <strong>npx prisma generate</strong>, pero esto no va a funcionar en la vida real</li>
<li>Aqui funciona porque uso SQLite y tengo la Db en el fileSystem ya creada, en la vida real usaría postgres o mongo</li>
<li>Si no tenemos la db ni las migraciones, lo que tengo en mi Schema debería ser suficiente para crear mi db</li>
<li>Pero desde el dockerfile estamos construyendo la imagen</li>
<li>Mi Schema lo ocupo para ejecutarlo</li>
<li>npx prisma generate solo es útil <strong>si la DB YA EXISTE</strong> por lo que con products si va a funcionar, pero con postgres no</li>
<li>Si no existiera crear con <strong>npx prisma migrate dev --name init</strong></li>
<li>Me aseguro de tener data en la DB</li>
<li>products dockerfile</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">FROM</span> node:<span class="hljs-number">20</span>-alpine3.<span class="hljs-number">19</span>

<span class="hljs-keyword">WORKDIR</span><span class="bash"> /usr/src/app</span>

<span class="hljs-keyword">COPY</span><span class="bash"> package.json ./</span>
<span class="hljs-keyword">COPY</span><span class="bash"> package-lock.json ./</span>


<span class="hljs-keyword">RUN</span><span class="bash"> npm install</span>

<span class="hljs-keyword">COPY</span><span class="bash"> . .</span>

<span class="hljs-keyword">RUN</span><span class="bash"> npx prisma generate </span>


<span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">3001</span>
</div></code></pre>
<ul>
<li>Para solucionar este problema en products y en orders creo un nuevo script en el json y lo coloco en el start:dev</li>
<li>No hace falta usar npx porque ya hemos creado el cliente desde el dockerfile products-ms</li>
</ul>
<pre class="hljs"><code><div>{
  <span class="hljs-attr">"docker:start"</span>:<span class="hljs-string">"prisma migrate dev &amp;&amp; prisma generate"</span>,
  <span class="hljs-attr">"start:dev"</span>:<span class="hljs-string">"npm run docker:start &amp;&amp; nest start --watch"</span>
}
</div></code></pre>
<ul>
<li>orders dockerfile</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">FROM</span> node:<span class="hljs-number">20</span>-alpine3.<span class="hljs-number">19</span>

<span class="hljs-keyword">WORKDIR</span><span class="bash"> /usr/src/app</span>

<span class="hljs-keyword">COPY</span><span class="bash"> package.json ./</span>
<span class="hljs-keyword">COPY</span><span class="bash"> package-lock.json ./</span>


<span class="hljs-keyword">RUN</span><span class="bash"> npm install</span>

<span class="hljs-keyword">COPY</span><span class="bash"> . .</span>

<span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">3002</span>
</div></code></pre>
<ul>
<li>En las .envs de orders-microservice coloco el string de conexión</li>
</ul>
<pre class="hljs"><code><div>PORT=3002


PRODUCTS_MICROSERVICE_HOST=localhost
PRODUCTS_MICROSERVICE_PORT=3001

DATABASE_URL=&quot;postgresql://postgres:123456@orders-db:5432/ordersdb?schema=public&quot;

# NATS_SERVERS=&quot;nats://localhost:4222,nats://localhost:4223&quot;
NATS_SERVERS=&quot;nats://localhost:4222&quot;
</div></code></pre>
<ul>
<li>Si observamos en Docker, nos podemos conectar a orders-db porque estamos mapeando los puertos</li>
<li>En la vida real esto no sería necesario, exponer la db de esta manera con 5432:5432</li>
<li>Si lo quito del docker-compose sigue funcionando igual pero tengo un error en TablePlus porque ya no tengo el puerto</li>
<li>Es genial, porque vamos a crear <strong>una red encapsulada</strong> para que los servicios puedan comunicarse entre si basado en los nombres de los servidores</li>
<li><strong>ESTO ES INCREIBLE</strong></li>
<li>Vamos a dejar el puerto porque me interesa seguir trabajando con TablePlus</li>
</ul>
<hr>
<h2 id="expandir-nuestro-custom-exception-filter">Expandir nuestro Custom Exception Filter</h2>
<ul>
<li>Cuando un microservicio no se levanta nos manda un error de Empty response. There are no subscribers listening to that message &quot;string del message pattern&quot;</li>
<li>Para centralizar las excepciones en client-gateway/src/exception/custom-esception.filter</li>
<li>En este momento, si voy al client-gateway.orders.controller <strong>no estoy disparando el exceptionFilter</strong></li>
<li>Si todo lo estoy manejando mediante un try y un catch, lo coherente es usarlo también en findAll</li>
</ul>
<pre class="hljs"><code><div>@Get()
findAll( @Query() orderPaginationDto: OrderPaginationDto ) {
  <span class="hljs-keyword">try</span>{
    <span class="hljs-keyword">const</span> orders = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.client.send(<span class="hljs-string">'findAllOrders'</span>, orderPaginationDto);
    <span class="hljs-keyword">return</span> orders
  }<span class="hljs-keyword">catch</span>(error){
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(error)
  }
}
</div></code></pre>
<ul>
<li>No hay muchas opciones para manejar el error. exception.name devuelve 'Error' y getError().toString tampoco resuelve mucho</li>
<li>Tengo una manera usando el .includes con el string que devuelve el error del microservicio no conectado &quot;Empty response etc&quot;</li>
<li>client-gateway.microservice/common/exceptions/rpc-custom-exception.filter.ts</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Catch, ArgumentsHost, ExceptionFilter } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;

<span class="hljs-keyword">import</span> { RpcException } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/microservices'</span>;

@Catch(RpcException)
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcCustomExceptionFilter</span> <span class="hljs-title">implements</span> <span class="hljs-title">ExceptionFilter</span> </span>{
  <span class="hljs-keyword">catch</span>(exception: RpcException, <span class="hljs-attr">host</span>: ArgumentsHost) {
    <span class="hljs-keyword">const</span> ctx = host.switchToHttp();
    <span class="hljs-keyword">const</span> response = ctx.getResponse();

    <span class="hljs-keyword">const</span> rpcError = exception.getError();

    <span class="hljs-keyword">if</span>(rpcError.toString().includes(<span class="hljs-string">'Empty response'</span>)){
      <span class="hljs-keyword">return</span> response.status(<span class="hljs-number">500</span>).json({
        <span class="hljs-attr">status</span>: <span class="hljs-number">500</span>,
        <span class="hljs-comment">//no me interesa mandar el string del messagePattern en el manejo de la excepción. Es info valiosa</span>
        <span class="hljs-comment">//uso toSubstring para quedarme con el error desde el principio hasta el paréntesis (donde aparece el string del controlador del microservicio) y le resto 1 para que no incluya el paréntesis</span>
        <span class="hljs-attr">message</span>: rpcError.toString().substring(<span class="hljs-number">0</span>, rpcError.toString().indexOf(<span class="hljs-string">'('</span>, <span class="hljs-number">-1</span>))
      })
    }

    <span class="hljs-keyword">if</span> (
      <span class="hljs-keyword">typeof</span> rpcError === <span class="hljs-string">'object'</span> &amp;&amp;
      <span class="hljs-string">'status'</span> <span class="hljs-keyword">in</span> rpcError &amp;&amp;
      <span class="hljs-string">'message'</span> <span class="hljs-keyword">in</span> rpcError
    ) {
      <span class="hljs-keyword">const</span> status = <span class="hljs-built_in">isNaN</span>(+rpcError.status) ? <span class="hljs-number">400</span> :+rpcError.status;
      <span class="hljs-keyword">return</span> response.status(status).json(rpcError);
    }

    response.status(<span class="hljs-number">400</span>).json({
      <span class="hljs-attr">status</span>: <span class="hljs-number">400</span>,
      <span class="hljs-attr">message</span>: rpcError,
    });
  }
}
</div></code></pre>
<hr>
<h2 id="monorepo-o-no-monorepo">Monorepo o no monorepo</h2>
<ul>
<li>Para usar submódulos paso el README</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-section">## Dev</span>
<span class="hljs-bullet">
1. </span>Clonar el repositorio
<span class="hljs-bullet">2. </span>Crear un .env basado en el .env.template
<span class="hljs-bullet">3. </span>Ejecutar el comando <span class="hljs-code">`git submodule update --init --recursive`</span> para reconstruir los sub-módulos
<span class="hljs-bullet">4. </span>Ejecutar el comando <span class="hljs-code">`docker compose up --build`</span>


<span class="hljs-section">### Pasos para crear los Git Submodules</span>
<span class="hljs-bullet">
1. </span>Crear un nuevo repositorio en GitHub
<span class="hljs-bullet">2. </span>Clonar el repositorio en la máquina local
<span class="hljs-bullet">3. </span>Añadir el submodule, donde <span class="hljs-code">`repository_url`</span> es la url del repositorio y <span class="hljs-code">`directory_name`</span> es el nombre de la carpeta donde quieres que se guarde el sub-módulo (no debe de existir en el proyecto)
<span class="hljs-code">```
git submodule add &lt;repository_url&gt; &lt;directory_name&gt;
```</span>
<span class="hljs-bullet">4. </span>Añadir los cambios al repositorio (git add, git commit, git push)
Ej:
<span class="hljs-code">```
git add .
git commit -m "Add submodule"
git push
```</span>
<span class="hljs-bullet">5. </span>Inicializar y actualizar Sub-módulos, cuando alguien clona el repositorio por primera vez, debe de ejecutar el siguiente comando para inicializar y actualizar los sub-módulos
<span class="hljs-code">```
git submodule update --init --recursive
```</span>
<span class="hljs-bullet">6. </span>Para actualizar las referencias de los sub-módulos
<span class="hljs-code">```
git submodule update --remote
```</span>


<span class="hljs-section">## Importante</span>
Si se trabaja en el repositorio que tiene los sub-módulos, <span class="hljs-strong">**primero actualizar y hacer push**</span> en el sub-módulo y <span class="hljs-strong">**después**</span> en el repositorio principal. 

Si se hace al revés, se perderán las referencias de los sub-módulos en el repositorio principal y tendremos que resolver conflictos.
</div></code></pre>
<ul>
<li>En la raíz del Launcher que alberga orders, products, etc coloco el .gitmodules con las direcciones de los repos (en este caso de Herrera)</li>
</ul>
<p>-.gitmodules</p>
<pre class="hljs"><code><div>[submodule &quot;client-gateway&quot;]
	path = client-gateway
	url = https://github.com/Nest-Microservices-DevTalles/client-gateway.git
[submodule &quot;products-ms&quot;]
	path = products-ms
	url = https://github.com/Nest-Microservices-DevTalles/products-microservice.git
[submodule &quot;orders-ms&quot;]
	path = orders-ms
	url = https://github.com/Nest-Microservices-DevTalles/orders-microservice.git
</div></code></pre>
<h2 id="trabajar-basado-en-el-launcher">Trabajar basado en el Launcher</h2>
<ul>
<li>Aquí fernando ha dado seguimiento a los archivos fuera de los microservicios como el docker-compose.yml y demás, y en submodulos los microservicios y el client-gateway</li>
<li>Puedo borrar el launcher de Docker y volverlo a levantar sin problemas</li>
<li>Si quiero trabajar solo con products-ms puedo comentar el orders-ms y la db en el docker-compose.yml</li>
</ul>
<hr>
<h1 id="nest-microservicios---payments">NEST MICROSERVICIOS - PAYMENTS</h1>
<ul>
<li>Primero trabajaré con payments-ms fuera de la red Docker</li>
<li>Será a través de una petición POST que realizaré la transacción</li>
<li>Estableceré y configuraré la conexión con Stripe, la secret-key en una variable de entorno que genraré en la web de Stripe y le pasaré a la nueva instancia de Stripe en el servicio tras validarla en el archivo envs.</li>
<li>Stripe hará lo que tenga que hacer (puede realizar el pago o cancelar) y mediante un webhook lo confirmaré</li>
</ul>
<hr>
<h2 id="configuraci%C3%B3n">Configuración</h2>
<ul>
<li>Creo una API (todavía no va a ser un microservice) fuera del Launcher con nest new paymenst-ms</li>
<li>Borro lo que no necesito</li>
<li>Creo el archivo de config/envs, requiere dos instalaciones dotenv i joi</li>
<li>De momento solo condfiguraré el puerto</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> <span class="hljs-string">'dotenv/config'</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> joi <span class="hljs-keyword">from</span> <span class="hljs-string">'joi'</span>;

interface EnvVars {
  <span class="hljs-attr">PORT</span>: number;
  
}

<span class="hljs-keyword">const</span> envsSchema = joi.object({
  <span class="hljs-attr">PORT</span>: joi.number().required(),

})
.unknown(<span class="hljs-literal">true</span>);

<span class="hljs-keyword">const</span> { error, value } = envsSchema.validate( process.env );


<span class="hljs-keyword">if</span> ( error ) {
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Config validation error: <span class="hljs-subst">${ error.message }</span>`</span>);
}

<span class="hljs-keyword">const</span> envVars:EnvVars = value;


<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> envs = {
  <span class="hljs-attr">port</span>: envVars.PORT
}
</div></code></pre>
<ul>
<li>En .env</li>
</ul>
<pre class="hljs"><code><div>PORT=3003
</div></code></pre>
<ul>
<li>Creemos un Logger en el main</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { NestFactory } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/core'</span>;
<span class="hljs-keyword">import</span> { AppModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.module'</span>;
<span class="hljs-keyword">import</span> { Logger } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { envs } <span class="hljs-keyword">from</span> <span class="hljs-string">'./config/envs'</span>;

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bootstrap</span>(<span class="hljs-params"></span>) </span>{

  <span class="hljs-keyword">const</span> logger = <span class="hljs-keyword">new</span> Logger(<span class="hljs-string">'Payments-microservice'</span>)


  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">await</span> NestFactory.create(AppModule);
  <span class="hljs-keyword">await</span> app.listen(envs.port);
  logger.log(<span class="hljs-string">`Server running on http://localhost:<span class="hljs-subst">${envs.port}</span>`</span>)
}
bootstrap();
</div></code></pre>
<ul>
<li>Creo dos métodos en el controlador</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Controller, Get, Post } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { PaymentsService } <span class="hljs-keyword">from</span> <span class="hljs-string">'./payments.service'</span>;

@Controller(<span class="hljs-string">'payments'</span>)
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentsController</span> </span>{
  <span class="hljs-keyword">constructor</span>(private readonly paymentsService: PaymentsService) {}

  @Post(<span class="hljs-string">'create-payment-session'</span>)
  createPaymentSession(){
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.paymentsService.createPaymentSession();
  }

  @Get(<span class="hljs-string">'success'</span>)
  success(){
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.paymentsService.success();
  }

  @Get(<span class="hljs-string">'cancel'</span>)
  cancel(){
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.paymentsService.cancel();
  }

  @Post(<span class="hljs-string">'webhool'</span>)
  <span class="hljs-keyword">async</span> stripeWebhook(){
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.paymentsService.stripeWebhook();
  }
}
</div></code></pre>
<ul>
<li>Instalo el paquete de Stripe con npm i</li>
<li>En el servicio creo una nueva instancia de Stripe y declaro los métodos que llamo desde el controlador</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Injectable } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;

@Injectable()
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentsService</span> </span>{
  
  createPaymentSession(): string {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'This action adds a new payment session'</span>;
  }

  success(): string {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'This action returns success'</span>;
  }

  cancel(): string {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'This action returns cancel'</span>;
  }

  stripeWebhook(): string {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'This action returns webhook'</span>;
  }

}

</div></code></pre>
<hr>
<h2 id="configuraci%C3%B3n-de-stripe">Configuración de Stripe</h2>
<ul>
<li>Para obtener la secret_key debo poner Stripe en modo Test y acudir al apartado Developer una vez logeado</li>
<li>Instalo stripe con npm i strip</li>
<li>Tienes la documentación en stripe docs</li>
<li>Valido la env STRIPE_SECRET en mi archivo de configuración /config/envs</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> <span class="hljs-string">'dotenv/config'</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> joi <span class="hljs-keyword">from</span> <span class="hljs-string">'joi'</span>;

interface EnvVars {
  <span class="hljs-attr">PORT</span>: number;
  STRIPE_SECRET_KEY: string;
  
}

<span class="hljs-keyword">const</span> envsSchema = joi.object({
  <span class="hljs-attr">PORT</span>: joi.number().required(),
  <span class="hljs-attr">STRIPE_SECRET_KEY</span>: joi.string().required(),
})
.unknown(<span class="hljs-literal">true</span>);

<span class="hljs-keyword">const</span> { error, value } = envsSchema.validate( process.env );


<span class="hljs-keyword">if</span> ( error ) {
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Config validation error: <span class="hljs-subst">${ error.message }</span>`</span>);
}

<span class="hljs-keyword">const</span> envVars:EnvVars = value;


<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> envs = {
  <span class="hljs-attr">port</span>: envVars.PORT,
  <span class="hljs-attr">stripeSecretKey</span>: envVars.STRIPE_SECRET_KEY
}
</div></code></pre>
<ul>
<li>En payments.service creo la instancia de Stripe con la secret_key de la env</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Injectable } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { envs } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/config/envs'</span>;
<span class="hljs-keyword">import</span> Stripe <span class="hljs-keyword">from</span> <span class="hljs-string">'stripe'</span>;

@Injectable()
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentsService</span> </span>{

  private readonly stripe = <span class="hljs-keyword">new</span> Stripe(envs.stripeSecretKey)
  
  createPaymentSession(): string {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'This action adds a new payment session'</span>;
  }

  success(): string {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'This action returns success'</span>;
  }

  cancel(): string {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'This action returns cancel'</span>;
  }

  stripeWebhook(): string {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'This action returns webhook'</span>;
  }

}
</div></code></pre>
<hr>
<h2 id="crear-sesi%C3%B3n-de-pago">Crear sesión de pago</h2>
<ul>
<li>En el método de payments.service createPaymentSession</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Injectable } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { envs } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/config/envs'</span>;
<span class="hljs-keyword">import</span> Stripe <span class="hljs-keyword">from</span> <span class="hljs-string">'stripe'</span>;

@Injectable()
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentsService</span> </span>{

  private readonly stripe = <span class="hljs-keyword">new</span> Stripe(envs.stripeSecretKey)
  
  <span class="hljs-keyword">async</span> createPaymentSession() {
    <span class="hljs-keyword">const</span> session = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.stripe.checkout.sessions.create({
      <span class="hljs-comment">//colocar aquí el id de mi order  </span>
      <span class="hljs-attr">payment_intent_data</span>:{
        <span class="hljs-attr">metadata</span>:{
          <span class="hljs-attr">order_id</span>: <span class="hljs-string">'order_123456789'</span>
        }
      },
      <span class="hljs-comment">//aquí van los items que la gente está comprando</span>
      <span class="hljs-attr">line_items</span>:[
        {
          <span class="hljs-attr">price_data</span>:{
            <span class="hljs-attr">currency</span>: <span class="hljs-string">'eur'</span>,
            <span class="hljs-attr">product_data</span>:{   <span class="hljs-comment">//product_data es para crear el producto en el momento. product es para referenciar un producto ya creado en Stripe</span>
              <span class="hljs-attr">name</span>: <span class="hljs-string">'T-shirt'</span>
            },
            <span class="hljs-attr">unit_amount</span>: <span class="hljs-number">2000</span> <span class="hljs-comment">//esto equivale a 20 euros (el precio del producto). No permite decimales como 20.00</span>
          },
          <span class="hljs-attr">quantity</span>: <span class="hljs-number">2</span> <span class="hljs-comment">//20*2 = 40 eur</span>
        }
      ],
      <span class="hljs-attr">mode</span>:<span class="hljs-string">'payment'</span>,
      <span class="hljs-attr">success_url</span>: <span class="hljs-string">'http://localhost:3003/payments/success'</span>,
      <span class="hljs-attr">cancel_url</span>: <span class="hljs-string">'http://localhost:3003/payments/cancel'</span>

     })

     <span class="hljs-keyword">return</span> session
  }


  success(): string {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'This action returns success'</span>;
  }

  cancel(): string {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'This action returns cancel'</span>;
  }

  stripeWebhook(): string {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'This action returns webhook'</span>;
  }

}
</div></code></pre>
<ul>
<li>Si voy al endpoint localhot:3003/payments/create-payment-session con POST obtengo esto</li>
</ul>
<pre class="hljs"><code><div>{
  <span class="hljs-attr">"id"</span>: <span class="hljs-string">"cs_test_a15xIlRB5KXo4TwX0rNjfm6Cw554MK22xFKxSUevuI6sqcZQcSXjq7abu4"</span>,
  <span class="hljs-attr">"object"</span>: <span class="hljs-string">"checkout.session"</span>,
  <span class="hljs-attr">"after_expiration"</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">"allow_promotion_codes"</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">"amount_subtotal"</span>: <span class="hljs-number">4000</span>,
  <span class="hljs-attr">"amount_total"</span>: <span class="hljs-number">4000</span>,
  <span class="hljs-attr">"automatic_tax"</span>: {
    <span class="hljs-attr">"enabled"</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">"liability"</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">"status"</span>: <span class="hljs-literal">null</span>
  },
  <span class="hljs-attr">"billing_address_collection"</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">"cancel_url"</span>: <span class="hljs-string">"http://localhost:3003/payments/cancel"</span>,
  <span class="hljs-attr">"client_reference_id"</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">"client_secret"</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">"consent"</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">"consent_collection"</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">"created"</span>: <span class="hljs-number">1715056083</span>,
  <span class="hljs-attr">"currency"</span>: <span class="hljs-string">"eur"</span>,
  <span class="hljs-attr">"currency_conversion"</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">"custom_fields"</span>: [],
  <span class="hljs-attr">"custom_text"</span>: {
    <span class="hljs-attr">"after_submit"</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">"shipping_address"</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">"submit"</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">"terms_of_service_acceptance"</span>: <span class="hljs-literal">null</span>
  },
  <span class="hljs-attr">"customer"</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">"customer_creation"</span>: <span class="hljs-string">"if_required"</span>,
  <span class="hljs-attr">"customer_details"</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">"customer_email"</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">"expires_at"</span>: <span class="hljs-number">1715142483</span>,
  <span class="hljs-attr">"invoice"</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">"invoice_creation"</span>: {
    <span class="hljs-attr">"enabled"</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">"invoice_data"</span>: {
      <span class="hljs-attr">"account_tax_ids"</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">"custom_fields"</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">"description"</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">"footer"</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">"issuer"</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">"metadata"</span>: {},
      <span class="hljs-attr">"rendering_options"</span>: <span class="hljs-literal">null</span>
    }
  },
  <span class="hljs-attr">"livemode"</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">"locale"</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">"metadata"</span>: {},
  <span class="hljs-attr">"mode"</span>: <span class="hljs-string">"payment"</span>,
  <span class="hljs-attr">"payment_intent"</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">"payment_link"</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">"payment_method_collection"</span>: <span class="hljs-string">"if_required"</span>,
  <span class="hljs-attr">"payment_method_configuration_details"</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">"payment_method_options"</span>: {
    <span class="hljs-attr">"card"</span>: {
      <span class="hljs-attr">"request_three_d_secure"</span>: <span class="hljs-string">"automatic"</span>
    }
  },
  <span class="hljs-attr">"payment_method_types"</span>: [
    <span class="hljs-string">"card"</span>
  ],
  <span class="hljs-attr">"payment_status"</span>: <span class="hljs-string">"unpaid"</span>,
  <span class="hljs-attr">"phone_number_collection"</span>: {
    <span class="hljs-attr">"enabled"</span>: <span class="hljs-literal">false</span>
  },
  <span class="hljs-attr">"recovered_from"</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">"saved_payment_method_options"</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">"setup_intent"</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">"shipping_address_collection"</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">"shipping_cost"</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">"shipping_details"</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">"shipping_options"</span>: [],
  <span class="hljs-attr">"status"</span>: <span class="hljs-string">"open"</span>,
  <span class="hljs-attr">"submit_type"</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">"subscription"</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">"success_url"</span>: <span class="hljs-string">"http://localhost:3003/payments/success"</span>,
  <span class="hljs-attr">"total_details"</span>: {
    <span class="hljs-attr">"amount_discount"</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">"amount_shipping"</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">"amount_tax"</span>: <span class="hljs-number">0</span>
  },
  <span class="hljs-attr">"ui_mode"</span>: <span class="hljs-string">"hosted"</span>,
  <span class="hljs-attr">"url"</span>: <span class="hljs-string">"https://checkout.stripe.com/c/pay/cs_test_a15xIlRB5KXo4TwX0rNjfm6Cw554MK22xFKxSUevuI6sqcZQcSXjq7abu4#fidkdWxOYHwnPyd1blpxYHZxWjA0VUFUfHBGcmFNZD1cR2JxV25gNDB8cFFIdjZcbkdLRFJiZHZvUFBdY2l1NDddUFNvTHdkY3RuQj1TSVxUcEZ9NFRGPEY0b11PfT1VVVI3M1RBV25Of2BnNTV3Xz1UcFFzYCcpJ2N3amhWYHdzYHcnP3F3cGApJ2lkfGpwcVF8dWAnPyd2bGtiaWBabHFgaCcpJ2BrZGdpYFVpZGZgbWppYWB3dic%2FcXdwYHgl"</span>
}
</div></code></pre>
<ul>
<li>Si le doy a la url del final me lleva a la pantalla de stripe con la opción de pagar 40 eur y para poner los datos de la tarjeta</li>
<li>Relleno los datos con datos ficticios (usar 4242 4242 4242 4242 para la tarjeta)</li>
<li>Una vez hecho el pago me redirecciona al endpoint success y puedo ver el pago desde la web de stripe como pago exitoso</li>
</ul>
<hr>
<h2 id="payment-session-dto">Payment Session DTO</h2>
<ul>
<li>En lugar de poner la información en duro, los datos que van en create-payment-session vendrá desde otro microservicio</li>
<li>Para trabajar con dtos hay queinstalar class-validator class-transformer</li>
<li>Hay que configurar el globalPipes en el main</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { NestFactory } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/core'</span>;
<span class="hljs-keyword">import</span> { AppModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.module'</span>;
<span class="hljs-keyword">import</span> { Logger, ValidationPipe } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { envs } <span class="hljs-keyword">from</span> <span class="hljs-string">'./config/envs'</span>;

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bootstrap</span>(<span class="hljs-params"></span>) </span>{

  <span class="hljs-keyword">const</span> logger = <span class="hljs-keyword">new</span> Logger(<span class="hljs-string">'Payments-microservice'</span>)


  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">await</span> NestFactory.create(AppModule);

  app.useGlobalPipes(<span class="hljs-keyword">new</span> ValidationPipe({
    <span class="hljs-attr">whitelist</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">forbidNonWhitelisted</span>: <span class="hljs-literal">true</span>
  }))

  <span class="hljs-keyword">await</span> app.listen(envs.port);
  logger.log(<span class="hljs-string">`Server running on http://localhost:<span class="hljs-subst">${envs.port}</span>`</span>)
}
bootstrap();
</div></code></pre>
<ul>
<li>En el dto</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Type } <span class="hljs-keyword">from</span> <span class="hljs-string">"class-transformer"</span>;
<span class="hljs-keyword">import</span> { ArrayMinSize, IsArray, IsNumber, IsPositive, IsString, ValidateNested } <span class="hljs-keyword">from</span> <span class="hljs-string">"class-validator"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentSessionDto</span> </span>{
    
    @IsString()
    <span class="hljs-attr">currency</span>: string
    
    @IsArray()
    @ArrayMinSize(<span class="hljs-number">1</span>)
    @ValidateNested({<span class="hljs-attr">each</span>:<span class="hljs-literal">true</span>})
    @Type(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>PaymentSessionItemDto) <span class="hljs-comment">//transformo items en instancias de PaymentSessionItemDto</span>
    <span class="hljs-attr">items</span>: PaymentSessionItemDto[]
}


<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentSessionItemDto</span></span>{
    @IsString()
    <span class="hljs-attr">name</span>: string

    @IsNumber()
    @IsPositive()
    <span class="hljs-attr">price</span>: number

    @IsNumber()
    @IsPositive()
    <span class="hljs-attr">quantity</span>: number
}
</div></code></pre>
<ul>
<li>Recojo del Body en el controller y valido con el dto</li>
</ul>
<pre class="hljs"><code><div>@Post(<span class="hljs-string">'create-payment-session'</span>)
  createPaymentSession(@Body()paymentSessionDto: PaymentSessionDto){
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.paymentsService.createPaymentSession(paymentSessionDto);
  }
</div></code></pre>
<ul>
<li>En el servicio recojo el dto</li>
<li>Debo pasarle al endpoint el objeto que me pide el dto en el body de POSTMAN o similares</li>
</ul>
<pre class="hljs"><code><div>{
  <span class="hljs-attr">"currency"</span>: <span class="hljs-string">"eur"</span>,
  <span class="hljs-attr">"items"</span>:[
    {
      <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Preservativos"</span>,
      <span class="hljs-attr">"price"</span>: <span class="hljs-number">18.03</span>,
      <span class="hljs-attr">"quantity"</span>: <span class="hljs-number">1</span>
    }]
}
</div></code></pre>
<ul>
<li>En el servicio extraemos con desestructuración la data para poder trabajar con ella</li>
<li>Hago un map de items y cojo el objeto que me pide la documentación y lo reconstruyo con mi data</li>
<li>Como el precio puede venir en decimales uso Math.round para redondear y le debo añadir 2 ceros para dejarlo en el formato de stripe</li>
<li>Le paso el lineItems a la session</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-keyword">async</span> createPaymentSession(paymentSessionDto:PaymentSessionDto) {

    <span class="hljs-keyword">const</span> {currency, items} = paymentSessionDto

    <span class="hljs-keyword">const</span> lineItems= items.map(<span class="hljs-function">(<span class="hljs-params">{name, price, quantity}</span>)=&gt;</span>{
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">price_data</span>:{
          currency,
          <span class="hljs-attr">product_data</span>:{   
            name 
          },
          <span class="hljs-attr">unit_amount</span>: <span class="hljs-built_in">Math</span>.round(price *<span class="hljs-number">100</span>)
        },
        quantity
      }
    })

    <span class="hljs-keyword">const</span> session = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.stripe.checkout.sessions.create({
      <span class="hljs-comment">//colocar aquí el id de mi order  </span>
      <span class="hljs-attr">payment_intent_data</span>:{
        <span class="hljs-attr">metadata</span>:{
          <span class="hljs-attr">order_id</span>: <span class="hljs-string">'order_123456789'</span>
        }
      },
      <span class="hljs-comment">//aquí van los items que la gente está comprando</span>
      <span class="hljs-attr">line_items</span>: lineItems,
      <span class="hljs-attr">mode</span>:<span class="hljs-string">'payment'</span>,
      <span class="hljs-attr">success_url</span>: <span class="hljs-string">'http://localhost:3003/payments/success'</span>,
      <span class="hljs-attr">cancel_url</span>: <span class="hljs-string">'http://localhost:3003/payments/cancel'</span>

     })

     <span class="hljs-keyword">return</span> session
  }
</div></code></pre>
<ul>
<li>Ahora falta configurar el webhook para ser notificados cuando el pago se haya realizado</li>
</ul>
<hr>
<h2 id="probando-webhooks-de-stripe">Probando webhooks de stripe</h2>
<ul>
<li>Caundo realizo un pago, Stripe mediante un POST manda a llamar el webhook y lo envia a mi endpoint</li>
<li>Tengo que controlar que sea stripe, con la firma de stripe</li>
<li>En la web de Stripe voy a Developers/webhooks (hay muchos!)</li>
<li>Añadir punto de conexión: podemos probar test in a local environment o directamente con un endpoint</li>
<li>Para el test in local environment hay que instalar el cliente de stripe (un zip, darle al exe y configrar el path). Se puede hacer a traves de Docker</li>
<li>Usaré un endpoint real directamente, selecciono los eventos a escuchar</li>
<li>Al lado derecho tenemos el código a implementar</li>
<li>Usa express, y nosotros también (debajo de Nest)</li>
<li>Dice que mandemos el body como un raw y eso puede ser un poco tedioso si queremos crear un middleware, pero Nest facilita mucho la faena</li>
<li>En el main, en app, coloco el rawBody en true</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { NestFactory } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/core'</span>;
<span class="hljs-keyword">import</span> { AppModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.module'</span>;
<span class="hljs-keyword">import</span> { Logger, ValidationPipe } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { envs } <span class="hljs-keyword">from</span> <span class="hljs-string">'./config/envs'</span>;

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bootstrap</span>(<span class="hljs-params"></span>) </span>{

  <span class="hljs-keyword">const</span> logger = <span class="hljs-keyword">new</span> Logger(<span class="hljs-string">'Payments-microservice'</span>)


  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">await</span> NestFactory.create(AppModule,{
    <span class="hljs-attr">rawBody</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">//esto va a mandar el body como un buffer que es exactamente lo que me piden</span>
  });

  app.useGlobalPipes(<span class="hljs-keyword">new</span> ValidationPipe({
    <span class="hljs-attr">whitelist</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">forbidNonWhitelisted</span>: <span class="hljs-literal">true</span>
  }))

  <span class="hljs-keyword">await</span> app.listen(envs.port);
  logger.log(<span class="hljs-string">`Server running on http://localhost:<span class="hljs-subst">${envs.port}</span>`</span>)
}
bootstrap();
</div></code></pre>
<ul>
<li>Va a venir la firma en los headers de la petición. Necesito la request</li>
</ul>
<pre class="hljs"><code><div>stripeWebhook(req: Request, <span class="hljs-attr">res</span>: Response) {
    <span class="hljs-keyword">const</span> sig = req.headers[<span class="hljs-string">'stripe-signature'</span>];
    <span class="hljs-keyword">return</span> res.status(<span class="hljs-number">200</span>).json({sig})
  }
</div></code></pre>
<ul>
<li>En el controller ocupo tomar la request</li>
</ul>
<pre class="hljs"><code><div>@Post(<span class="hljs-string">'webhook'</span>)
<span class="hljs-keyword">async</span> stripeWebhook(@Req() req: Request,@Res() res:Response){
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.paymentsService.stripeWebhook(req,res);
}
</div></code></pre>
<hr>
<h2 id="implementar-el-webhook">Implementar el Webhook</h2>
<ul>
<li>Si procesamos el Body vamos a tener un error, porque Stripe lo verifica</li>
<li>Por eso lo tomamos directamente de la Request</li>
<li>Creo un evento</li>
<li>Copio el endpointSecret de la documentación</li>
<li>En un try catch, de la req tomo el rawBody (hay que escribirlo asi), el signature y el endpointSecret</li>
</ul>
<pre class="hljs"><code><div>  stripeWebhook(req: Request, <span class="hljs-attr">res</span>: Response) {
    <span class="hljs-keyword">const</span> sig = req.headers[<span class="hljs-string">'stripe-signature'</span>];


    <span class="hljs-keyword">let</span> event: Stripe.Event
    <span class="hljs-keyword">const</span> endpointSecret = <span class="hljs-string">"whsec_c74a813338de786ac11af0b167e3b53e74f63303a960b7cc6adcc5f585cf088d"</span>;


    <span class="hljs-keyword">try</span> {
      event = <span class="hljs-keyword">this</span>.stripe.webhooks.constructEvent(req[<span class="hljs-string">'rawBody'</span>], sig, endpointSecret);
    } <span class="hljs-keyword">catch</span> (err) {
      res.status(<span class="hljs-number">400</span>).send(<span class="hljs-string">`Webhook Error: <span class="hljs-subst">${err.message}</span>`</span>);
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">return</span> res.status(<span class="hljs-number">200</span>).json({sig})
  }
</div></code></pre>
<ul>
<li>Si no hace match con el endpointSecret mandará un error</li>
<li>Si estoy probandolo localmente y he instalado el cliente puedo usar stripe trigger payment_intent.succeeded</li>
<li>Esto me devuelve charge.succeded, payment_intent.succeded y payment_intent.created (Stripe primero crea un intento de pago)</li>
<li>Charge succeded es la confirmación</li>
<li>Si pruebo el webhook con un aurl, no voy a poder usar localhost</li>
<li>Vamos a tener que usar un Proxy o algo intermedio</li>
</ul>
<hr>
<h2 id="hookdeck---eventgateway---forwarder">Hookdeck - EventGateway - Forwarder</h2>
<ul>
<li>Podemos usar un switch para tomar el tipo de evento que me devuelve el webhook y realizar una acción</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">async</span> stripeWebhook(req: Request, <span class="hljs-attr">res</span>: Response) {
    <span class="hljs-keyword">const</span> sig = req.headers[<span class="hljs-string">'stripe-signature'</span>];


    <span class="hljs-keyword">let</span> event: Stripe.Event
    <span class="hljs-keyword">const</span> endpointSecret = <span class="hljs-string">"whsec_c74a813338de786ac11af0b167e3b53e74f63303a960b7cc6adcc5f585cf088d"</span>;


    <span class="hljs-keyword">try</span> {
      event = <span class="hljs-keyword">this</span>.stripe.webhooks.constructEvent(req[<span class="hljs-string">'rawBody'</span>], sig, endpointSecret);
    } <span class="hljs-keyword">catch</span> (err) {
      res.status(<span class="hljs-number">400</span>).send(<span class="hljs-string">`Webhook Error: <span class="hljs-subst">${err.message}</span>`</span>);
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">switch</span>(event.type){
      <span class="hljs-keyword">case</span> <span class="hljs-string">'charge.succeeded'</span>:
        <span class="hljs-comment">//llamar al microservicio</span>
        <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">default</span>: 
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Evento  <span class="hljs-subst">${event}</span> not handled`</span>)
    }

    <span class="hljs-keyword">return</span> res.status(<span class="hljs-number">200</span>).json({sig})
  }
</div></code></pre>
<ul>
<li>Para obtener la url usaremos hoockdeck</li>
<li>hay otros: smee (no funciona con stripe porque procesa el body)</li>
<li>le coloco un nombre cualquiera al endpoint fuente stripe-to-localhost</li>
<li>Le coloco otronombre cualquiera al endpoint destino to-localhost</li>
<li>Instalo el CLI</li>
</ul>
<blockquote>
<p>npm install hookdeck-cli -g</p>
</blockquote>
<ul>
<li>En endpoint url coloco el localhost:3003/payments/webhook (solo payments/webhook)</li>
<li>recibo un url. Lo debo colocar en la parte de Stripe</li>
</ul>
<blockquote>
<p>https://hkdk.events/nan95cp9850tx9</p>
</blockquote>
<ul>
<li>Ahora solo tengo que usar el CLI</li>
</ul>
<blockquote>
<p>hookdeck login
hookdeck listen 3003 stripe-to-localhost</p>
</blockquote>
<ul>
<li>Si apunto con un POST a http://localhost:3003/payments/webhook  debería darme un error como Webhook Error: No webhook payload was provided.</li>
<li>Todavía no hemos añadido el string a stripe</li>
<li>En developers/webhooks/añadir punto de conexión coloco la uRL</li>
<li>Escucho el evento charge.failed y charge.succeeded</li>
<li>Añadir evento</li>
<li>Copio el secreto de firma de la pantalla esperando eventos...  (el de ahora es el real, el anterior era de testing)</li>
<li>Hago todo el proceso de crear y pagar y me manda a la pantalla de this action returns success que es lo que tengo en el endpoint de success</li>
<li>Puedo hacer console.logs para chequear eventos y demás</li>
</ul>
<hr>
<h2 id="enviar-y-recibir-la-id-de-la-orden">Enviar y recibir la Id de la orden</h2>
<ul>
<li>Necesito el orderId (UUID) de mi orders-ms</li>
<li>Puedo grabar el id de la transacción en order, o el URL de receipt_url del recibo (conveniente)</li>
<li>En PaymentSessionDto creo el orderId como string</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentSessionDto</span> </span>{
    
    @IsString()
    <span class="hljs-attr">orderId</span>: string

    @IsString()
    <span class="hljs-attr">currency</span>: string
    
    @IsArray()
    @ArrayMinSize(<span class="hljs-number">1</span>)
    @ValidateNested({<span class="hljs-attr">each</span>:<span class="hljs-literal">true</span>})
    @Type(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>PaymentSessionItemDto)
    <span class="hljs-attr">items</span>: PaymentSessionItemDto[]
}
</div></code></pre>
<ul>
<li>En el payments.service.create extraigo la orderId con desestructuración</li>
<li>Lo coloco en la metadata de la session</li>
<li>Podemos tomar la información del evento en el switch</li>
<li><strong>NOTA</strong>: he configurado las variables de entorno</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Injectable } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { envs } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/config'</span>;
<span class="hljs-keyword">import</span> Stripe <span class="hljs-keyword">from</span> <span class="hljs-string">'stripe'</span>;
<span class="hljs-keyword">import</span> { PaymentSessionDto } <span class="hljs-keyword">from</span> <span class="hljs-string">'./dto/payment-session.dto'</span>;
<span class="hljs-keyword">import</span> { Request, Response } <span class="hljs-keyword">from</span> <span class="hljs-string">'express'</span>;

@Injectable()
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentsService</span> </span>{
  private readonly stripe = <span class="hljs-keyword">new</span> Stripe(envs.stripeSecret);

  <span class="hljs-keyword">async</span> createPaymentSession(paymentSessionDto: PaymentSessionDto) {
    <span class="hljs-keyword">const</span> { currency, items, orderId } = paymentSessionDto; <span class="hljs-regexp">/7extraigo la orderId

    const lineItems = items.map((item) =&gt; {
      return {
        price_data: {
          currency: currency,
          product_data: {
            name: item.name,
          },
          unit_amount: Math.round(item.price * 100),
        },
        quantity: item.quantity,
      };
    });

    const session = await this.stripe.checkout.sessions.create({
      /</span><span class="hljs-regexp">/ Colocar aquí el ID de mi orden
      payment_intent_data: {
        metadata: {
          orderId: orderId
        },
      },
      line_items: lineItems,
      mode: 'payment',
      success_url: envs.stripeSuccessUrl,
      cancel_url: envs.stripeCancelUrl,
    });

    return session;
  }

  async stripeWebhook(req: Request, res: Response) {
    const sig = req.headers['stripe-signature'];

    let event: Stripe.Event;

    /</span><span class="hljs-regexp">/ Real
    const endpointSecret = envs.stripeEndpointSecret;

    try {
      event = this.stripe.webhooks.constructEvent(
        req['rawBody'],
        sig,
        endpointSecret,
      );
    } catch (err) {
      res.status(400).send(`Webhook Error: ${err.message}`);
      return;
    }
    
    switch( event.type ) {
      case 'charge.succeeded': 
        const chargeSucceeded = event.data.object;
        /</span><span class="hljs-regexp">/ TODO: llamar nuestro microservicio
        console.log({
          metadata: chargeSucceeded.metadata,
          orderId: chargeSucceeded.metadata.orderId,
        });
      break;
      
      default:
        console.log(`Event ${ event.type } not handled`);
    }

    return res.status(200).json({ sig });
  }
}
</span></div></code></pre>
<ul>
<li>Ahora debo hacer un pago. Recuerda tener el hoockdeck corriendo en la terminal</li>
<li><strong>NOTA</strong>: Estoy teniendo problemas con hookdeck, usaré ngrok</li>
<li>Abrir cmd como admin</li>
</ul>
<blockquote>
<p>choco install ngrok</p>
</blockquote>
<blockquote>
<p>ngrok http 3003</p>
</blockquote>
<ul>
<li>En stripe coloco el endpoint con la ruta que me da ngrok</li>
</ul>
<blockquote>
<p>https://03b6-2-152-179-155.ngrok-free.app/payments/webhook</p>
</blockquote>
<ul>
<li>En la documentacion dice que debes añadir la clave secreta del webhook que te proporciona stripe con</li>
</ul>
<blockquote>
<p>ngrok http 8080 --verify-webhook=stripe --verify-webhook-secret=mySecret</p>
</blockquote>
<ul>
<li>Necesito obtener el UUID de orders-microservices</li>
</ul>
<hr>
<h1 id="nest-microservicios---integrar-orders-y-payments">NEST MICROSERVICIOS - INTEGRAR ORDERS Y PAYMENTS</h1>
<ul>
<li>Integraremos payments a nuestra red de Docker</li>
<li>Cuando desde el client-gateway entra la creación de una orden es el microservicio de la creación de la orden quien va a hablar con payments-ms</li>
<li>Payments espera los productos, el id, etc y con esto creará la sesión que regresará una url, que mandamos de nuevo a la order para que la retorne a quien sea que creó la orden de pago</li>
<li>La persona irá a pagar a Stripe. Una vez paga respondemos con exito o no, pero es nuestro webhook quien va a comunciarse con Stripe para verificar que la orden fue pagada, y el webhook también se comunicará con orders-ms para que lo marque como pagado</li>
<li>Hemos visto el MessagePattern, que espera una respuesta, y ahora veremos EventPattern que es yo te envío un mensaje y sigo con mi vida, me da igual si respondes o no</li>
<li>Esto es util, porque vamos a tener el webhook, la respuesta rápida que está esperando Stripe (un 200 o 400)</li>
<li>Y en nuestro lado si vamos a recibir ese evento y procesamos toda la info</li>
<li>Suena complicado pero son simplemente muchos pasos lógicos</li>
<li>EL que yo tenga varios NULL en la DB en la fecha cuando se pagó se puede ver como una mala práctica</li>
<li>Podría verse como una mala práctica tener en la columna de cuando es la fecha en que se pago NULL</li>
<li>Es mejor tener una tabla aparte sin nulos, donde la orden se creó en tal fecha. Solo tener ahí las órdenes pagadas</li>
<li>Los pagos se comunican a través de NATS con orders y con el gateway que es quién se comuncia con el cliente</li>
<li>El webhook tiene que hablar con NATS y notifique al orders-ms que notifique que tal orden fue pagada y guardar el recibo en base de datos</li>
</ul>
<hr>
<h2 id="agregar-repositorio-al-launcher">Agregar Repositorio al Launcher</h2>
<ul>
<li>Agreguemos la imagen en el docker-compose.yml de la raíaz del launcher</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-attr">version:</span> <span class="hljs-string">'3'</span>


<span class="hljs-attr">services:</span>

  
  <span class="hljs-attr">nats-server:</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">nats:latest</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">"8222:8222"</span>
    

  <span class="hljs-attr">client-gateway:</span>
    <span class="hljs-attr">build:</span> <span class="hljs-string">./client-gateway</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">${CLIENT_GATEWAY_PORT}:3000</span>
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">./client-gateway/src:/usr/src/app/src</span>
    <span class="hljs-attr">command:</span> <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">start:dev</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">PORT=3000</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">NATS_SERVERS=nats://nats-server:4222</span>

  <span class="hljs-attr">products-ms:</span>
    <span class="hljs-attr">build:</span> <span class="hljs-string">./products-ms</span>
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">./products-ms/src:/usr/src/app/src</span>
    <span class="hljs-attr">command:</span> <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">start:dev</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">PORT=3001</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">NATS_SERVERS=nats://nats-server:4222</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">DATABASE_URL=file:./dev.db</span>

  
  <span class="hljs-comment"># Orders MS</span>
  <span class="hljs-attr">orders-ms:</span>
    <span class="hljs-attr">depends_on:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">orders-db</span>
    <span class="hljs-attr">build:</span> <span class="hljs-string">./orders-ms</span>
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">./orders-ms/src:/usr/src/app/src</span>
    <span class="hljs-attr">command:</span> <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">start:dev</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">PORT=3002</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">DATABASE_URL=postgresql://postgres:123456@orders-db:5432/ordersdb?schema=public</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">NATS_SERVERS=nats://nats-server:4222</span>



  <span class="hljs-comment"># Orders DB</span>
  <span class="hljs-attr">orders-db:</span>
    <span class="hljs-attr">container_name:</span> <span class="hljs-string">orders_database</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">postgres:16.2</span>
    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">./orders-ms/postgres:/var/lib/postgresql/data</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-number">5432</span><span class="hljs-string">:5432</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">POSTGRES_USER=postgres</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">POSTGRES_PASSWORD=123456</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">POSTGRES_DB=ordersdb</span>

<span class="hljs-comment"># ======================</span>
<span class="hljs-comment"># Payments Microservice</span>
<span class="hljs-comment"># ======================</span>
  <span class="hljs-attr">payments-ms:</span>
    <span class="hljs-attr">container_name:</span> <span class="hljs-string">payments-ms</span>
    <span class="hljs-attr">build:</span> <span class="hljs-string">./payments-ms</span>
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">./payments-ms/src:/usr/src/app/src</span>
    <span class="hljs-attr">command:</span> <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">start:dev</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">${PAYMENTS_MS_PORT}:${PAYMENTS_MS_PORT}</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">PORT=${PAYMENTS_MS_PORT}</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">NATS_SERVERS=nats://nats-server:4222</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">STRIPE_SECRET=${STRIPE_SECRET}</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">STRIPE_SUCCESS_URL=${STRIPE_SUCCESS_URL}</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">STRIPE_CANCEL_URL=${STRIPE_CANCEL_URL}</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">STRIPE_ENDPOINT_SECRET=${STRIPE_ENDPOINT_SECRET}</span>
</div></code></pre>
<ul>
<li>En orders-ms también tengo un .yml</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-attr">version:</span> <span class="hljs-string">'3'</span>


<span class="hljs-attr">services:</span>
  <span class="hljs-attr">orders-db:</span>
    <span class="hljs-attr">container_name:</span> <span class="hljs-string">orders_database</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">postgres:16.2</span>
    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">./postgres:/var/lib/postgresql/data</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-number">5432</span><span class="hljs-string">:5432</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">POSTGRES_USER=postgres</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">POSTGRES_PASSWORD=123456</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">POSTGRES_DB=ordersdb</span>
</div></code></pre>
<ul>
<li>Y el dockerfile de orders-ms</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">FROM</span> node:<span class="hljs-number">21</span>-alpine3.<span class="hljs-number">19</span>

<span class="hljs-keyword">WORKDIR</span><span class="bash"> /usr/src/app</span>

<span class="hljs-keyword">COPY</span><span class="bash"> package.json ./</span>
<span class="hljs-keyword">COPY</span><span class="bash"> package-lock.json ./</span>


<span class="hljs-keyword">RUN</span><span class="bash"> npm install</span>

<span class="hljs-keyword">COPY</span><span class="bash"> . .</span>

<span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">3002</span>
</div></code></pre>
<ul>
<li>En el dockerfile de products genero el cliente</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">FROM</span> node:<span class="hljs-number">21</span>-alpine3.<span class="hljs-number">19</span>

<span class="hljs-keyword">WORKDIR</span><span class="bash"> /usr/src/app</span>

<span class="hljs-keyword">COPY</span><span class="bash"> package.json ./</span>
<span class="hljs-keyword">COPY</span><span class="bash"> package-lock.json ./</span>


<span class="hljs-keyword">RUN</span><span class="bash"> npm install</span>

<span class="hljs-keyword">COPY</span><span class="bash"> . .</span>

<span class="hljs-keyword">RUN</span><span class="bash"> npx prisma generate</span>


<span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">3001</span>
</div></code></pre>
<ul>
<li>El dockerfile de client y payments es igual al de orders</li>
</ul>
<hr>
<h2 id="microservicio-h%C3%ADbrido---rest---nats">Microservicio híbrido - REST - NATS</h2>
<ul>
<li>Porqué híbrido</li>
<li>Al comunicarse payments-ms con nats podrá comunicarse con los otros microservicios</li>
<li>Puedo aplicar un puerto (desde mi REST) para que Stripe mediante el webhook hable con payments</li>
<li>Puedo no hacerlo híbrido y hacer que stripe se comunique como otro cliente a través del gateway</li>
<li>O crear otro servidor, otro gateway</li>
<li>O crear en el gateway otro POST que esté pendiente del endpoint de Stripe/webhook, pero no me interesa exponer payments, que alguien desde el exterior pueda acceder ahí</li>
<li>En el main de payments-ms</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { NestFactory } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/core'</span>;
<span class="hljs-keyword">import</span> { Logger, ValidationPipe } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { AppModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.module'</span>;
<span class="hljs-keyword">import</span> { envs } <span class="hljs-keyword">from</span> <span class="hljs-string">'./config'</span>;
<span class="hljs-keyword">import</span> { MicroserviceOptions, Transport } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/microservices'</span>;

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bootstrap</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> logger = <span class="hljs-keyword">new</span> Logger(<span class="hljs-string">'Payments-ms'</span>);

  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">await</span> NestFactory.create(AppModule, {
    <span class="hljs-attr">rawBody</span>: <span class="hljs-literal">true</span>
  });

  app.useGlobalPipes(
    <span class="hljs-keyword">new</span> ValidationPipe({
      <span class="hljs-attr">whitelist</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">forbidNonWhitelisted</span>: <span class="hljs-literal">true</span>,
    }),
  );


  <span class="hljs-comment">//conecto el microservicio al NATS</span>
  app.connectMicroservice&lt;MicroserviceOptions&gt;({
    <span class="hljs-attr">transport</span>: Transport.NATS,
    <span class="hljs-attr">options</span>: {
      <span class="hljs-attr">servers</span>: envs.natsServers, <span class="hljs-comment">//"nats://localhost:4222,nats://localhost:4223"</span>
    },
  }, {
    <span class="hljs-attr">inheritAppConfig</span>: <span class="hljs-literal">true</span>
  })


  <span class="hljs-keyword">await</span> app.startAllMicroservices();
  
  <span class="hljs-keyword">await</span> app.listen(envs.port);

  logger.log(<span class="hljs-string">`Payments Microservice running on port <span class="hljs-subst">${envs.port}</span>`</span>);
}
bootstrap();

</div></code></pre>
<ul>
<li>Configuro las variables de entorno en payments/src/config/envs</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> <span class="hljs-string">'dotenv/config'</span>;

<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> joi <span class="hljs-keyword">from</span> <span class="hljs-string">'joi'</span>;

interface EnvVars {
  <span class="hljs-attr">PORT</span>: number;

  STRIPE_SECRET: string;
  STRIPE_SUCCESS_URL: string;
  STRIPE_CANCEL_URL: string;
  STRIPE_ENDPOINT_SECRET: string;

  NATS_SERVERS: string[];
}

<span class="hljs-keyword">const</span> envsSchema = joi.object({
  <span class="hljs-attr">PORT</span>: joi.number().required(),

  <span class="hljs-attr">STRIPE_SECRET</span>: joi.string().required(),
  <span class="hljs-attr">STRIPE_SUCCESS_URL</span>: joi.string().required(),
  <span class="hljs-attr">STRIPE_CANCEL_URL</span>: joi.string().required(),
  <span class="hljs-attr">STRIPE_ENDPOINT_SECRET</span>: joi.string().required(),

  <span class="hljs-attr">NATS_SERVERS</span>: joi.array().items( joi.string() ).required(),
})
.unknown(<span class="hljs-literal">true</span>);

<span class="hljs-keyword">const</span> { error, value } = envsSchema.validate({ 
  ...process.env,
  <span class="hljs-attr">NATS_SERVERS</span>: process.env.NATS_SERVERS?.split(<span class="hljs-string">','</span>)
});


<span class="hljs-keyword">if</span> ( error ) {
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Config validation error: <span class="hljs-subst">${ error.message }</span>`</span>);
}

<span class="hljs-keyword">const</span> envVars:EnvVars = value;


<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> envs = {
  <span class="hljs-attr">port</span>: envVars.PORT,
  
  <span class="hljs-attr">stripeSecret</span>: envVars.STRIPE_SECRET,
  <span class="hljs-attr">stripeSuccessUrl</span>: envVars.STRIPE_SUCCESS_URL,
  <span class="hljs-attr">stripeCancelUrl</span>: envVars.STRIPE_CANCEL_URL,
  <span class="hljs-attr">stripeEndpointSecret</span>: envVars.STRIPE_ENDPOINT_SECRET,

  <span class="hljs-attr">natsServers</span>: envVars.NATS_SERVERS,
}
</div></code></pre>
<hr>
<h2 id="paymentsession-dede-orders-ms">PaymentSession dede orders-ms</h2>
<ul>
<li>Yo puedo acceder a 3003/payments/create-payment... y quiero evitarlo</li>
<li>Puedo decir que el POST también recibe el MessagePattern</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// @Post('create-payment-session')</span>
@MessagePattern(<span class="hljs-string">'create.payment.session'</span>)
createPaymentSession(@Payload() paymentSessionDto: PaymentSessionDto ) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.paymentsService.createPaymentSession(paymentSessionDto);
}
</div></code></pre>
<ul>
<li>Cuando establezco el microservicio (con startAllMicroservices) automáticamente no va a aplicar el class-validator y class-transform</li>
<li>No va a servir la configuración en el main de siempre con GlobalPipes</li>
<li>En orders-ms-controller, tan pronto como creo la orden quiero crear la sesión</li>
</ul>
<pre class="hljs"><code><div>@MessagePattern(<span class="hljs-string">'createOrder'</span>)
<span class="hljs-keyword">async</span> create(@Payload() createOrderDto: CreateOrderDto) {

  <span class="hljs-comment">//pongo el cursor encima de order para obtener la interfaz a través de lo que construimos</span>
  <span class="hljs-keyword">const</span> order = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.ordersService.create(createOrderDto);
  <span class="hljs-keyword">const</span> paymentSession = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.ordersService.createPaymentSession(order)<span class="hljs-comment">//vamos a crear este método en el servicio</span>

  <span class="hljs-keyword">return</span> {
    order,
    paymentSession, <span class="hljs-comment">//lo coloco aquí para poderlo observar</span>
  }
}
</div></code></pre>
<ul>
<li>Si pongo el cursor encima de la variable order, la intellisense me muestra la interfaz</li>
<li>La copio</li>
<li>Creo en src/orders/interfaces/order-with-products.ts</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { OrderStatus } <span class="hljs-keyword">from</span> <span class="hljs-string">'@prisma/client'</span>;


<span class="hljs-keyword">export</span> interface OrderWithProducts {
  <span class="hljs-attr">OrderItem</span>: {
      <span class="hljs-attr">name</span>: any;
      productId: number;
      quantity: number;
      price: number;
  }[];
  id: string;
  totalAmount: number;
  totalItems: number;
  status: OrderStatus; <span class="hljs-comment">//Le quito $Enums.</span>
  paid: boolean;
  paidAt: <span class="hljs-built_in">Date</span>;
  createdAt: <span class="hljs-built_in">Date</span>;
  updatedAt: <span class="hljs-built_in">Date</span>;
}
</div></code></pre>
<ul>
<li>Paso el schema de prisma de orders-ms</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// This is your Prisma schema file,</span>
<span class="hljs-comment">// learn more about it in the docs: https://pris.ly/d/prisma-schema</span>

<span class="hljs-comment">// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?</span>
<span class="hljs-comment">// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init</span>

generator client {
  provider = <span class="hljs-string">"prisma-client-js"</span>
}

datasource db {
  provider = <span class="hljs-string">"postgresql"</span>
  url      = env(<span class="hljs-string">"DATABASE_URL"</span>)
}

enum OrderStatus {
  PENDING
  PAID
  DELIVERED
  CANCELLED
}

model Order {
  id          <span class="hljs-built_in">String</span> @id @<span class="hljs-keyword">default</span>(uuid())
  totalAmount Float
  totalItems  Int

  status         OrderStatus @<span class="hljs-keyword">default</span>(PENDING)
  paid           <span class="hljs-built_in">Boolean</span>     @<span class="hljs-keyword">default</span>(<span class="hljs-literal">false</span>)
  paidAt         DateTime?
  stripeChargeId <span class="hljs-built_in">String</span>?

  createdAt DateTime @<span class="hljs-keyword">default</span>(now())
  updatedAt DateTime @updatedAt

  OrderItem    OrderItem[]
  OrderReceipt OrderReceipt?
}

model OrderItem {
  id        <span class="hljs-built_in">String</span> @id @<span class="hljs-keyword">default</span>(uuid())
  productId Int
  quantity  Int
  price     Float

  Order   Order?  @relation(fields: [orderId], <span class="hljs-attr">references</span>: [id])
  orderId <span class="hljs-built_in">String</span>?
}

model OrderReceipt {
  id <span class="hljs-built_in">String</span> @id @<span class="hljs-keyword">default</span>(uuid())

  order   Order  @relation(fields: [orderId], <span class="hljs-attr">references</span>: [id])
  orderId <span class="hljs-built_in">String</span> @unique

  receiptUrl <span class="hljs-built_in">String</span>

  createdAt DateTime @<span class="hljs-keyword">default</span>(now())
  updatedAt DateTime @updatedAt

}
</div></code></pre>
<ul>
<li>Creo el método en orders-ms.orders.service para enviarle la orden con los productos, al payments-ms.payments.controller</li>
<li>Uso el firstValueFrom con dentro el .send para tratarlo como una promesa</li>
<li>El payload todavía no lo tengo</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">async</span> createPaymentSession(order: OrderWithProducts) {

    <span class="hljs-keyword">const</span> paymentSession = <span class="hljs-keyword">await</span> firstValueFrom(
      <span class="hljs-keyword">this</span>.client.send(<span class="hljs-string">'create.payment.session'</span>, { 
            <span class="hljs-attr">abc</span>: <span class="hljs-number">123</span>,
            <span class="hljs-attr">xyz</span>:<span class="hljs-number">234</span>
        })),
      
    

    <span class="hljs-keyword">return</span> paymentSession;
  }
</div></code></pre>
<ul>
<li>En el payments-ms.payments.controller le paso el dto al service de payments</li>
<li>Extraigo la data del dto, hago unmap de los items y creo el objeto para Stripe</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">async</span> createPaymentSession(paymentSessionDto: PaymentSessionDto) {
  <span class="hljs-keyword">const</span> { currency, items, orderId } = paymentSessionDto;

  <span class="hljs-keyword">const</span> lineItems = items.map(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">price_data</span>: {
        <span class="hljs-attr">currency</span>: currency,
        <span class="hljs-attr">product_data</span>: {
          <span class="hljs-attr">name</span>: item.name,
        },
        <span class="hljs-attr">unit_amount</span>: <span class="hljs-built_in">Math</span>.round(item.price * <span class="hljs-number">100</span>), <span class="hljs-comment">// 20 dólares 2000 / 100 = 20.00 // 15.0000</span>
      },
      <span class="hljs-attr">quantity</span>: item.quantity,
    };
  });
}
</div></code></pre>
<ul>
<li>Si creo una orden desde el endpoint, en el objeto total tengo un objeto que es paymentSession que recibimos del orders.service</li>
<li>No debería de pasar porque en el payments.controller lo estamos validando contra el paymentSessionDto del payments.controller</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// @Post('create-payment-session')</span>
@MessagePattern(<span class="hljs-string">'create.payment.session'</span>)
createPaymentSession(@Payload() paymentSessionDto: PaymentSessionDto ) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.paymentsService.createPaymentSession(paymentSessionDto);
}
</div></code></pre>
<ul>
<li>Hay que configurarlo en el main (de payments) cuando no son aplicaciones basadas en HTTP con inheritAppConfig</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { NestFactory } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/core'</span>;
<span class="hljs-keyword">import</span> { Logger, ValidationPipe } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { AppModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.module'</span>;
<span class="hljs-keyword">import</span> { envs } <span class="hljs-keyword">from</span> <span class="hljs-string">'./config'</span>;
<span class="hljs-keyword">import</span> { MicroserviceOptions, Transport } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/microservices'</span>;

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bootstrap</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> logger = <span class="hljs-keyword">new</span> Logger(<span class="hljs-string">'Payments-ms'</span>);

  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">await</span> NestFactory.create(AppModule, {
    <span class="hljs-attr">rawBody</span>: <span class="hljs-literal">true</span>
  });

  app.useGlobalPipes(
    <span class="hljs-keyword">new</span> ValidationPipe({
      <span class="hljs-attr">whitelist</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">forbidNonWhitelisted</span>: <span class="hljs-literal">true</span>,
    }),
  );

  app.connectMicroservice&lt;MicroserviceOptions&gt;({
    <span class="hljs-attr">transport</span>: Transport.NATS,
    <span class="hljs-attr">options</span>: {
      <span class="hljs-attr">servers</span>: envs.natsServers,
    },
  }, {
    <span class="hljs-attr">inheritAppConfig</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">//configuro la validación </span>
  })


  <span class="hljs-keyword">await</span> app.startAllMicroservices();
  
  <span class="hljs-keyword">await</span> app.listen(envs.port);

  logger.log(<span class="hljs-string">`Payments Microservice running on port <span class="hljs-subst">${envs.port}</span>`</span>);
}
bootstrap();
</div></code></pre>
<ul>
<li>En orders.service tengo que pasar que valide los dtos de payments-ms/src/payments/dto</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Type } <span class="hljs-keyword">from</span> <span class="hljs-string">'class-transformer'</span>;
<span class="hljs-keyword">import</span> { ArrayMinSize, IsArray, IsNumber, IsPositive, IsString, ValidateNested } <span class="hljs-keyword">from</span> <span class="hljs-string">'class-validator'</span>;


<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentSessionDto</span> </span>{


  @IsString()
  <span class="hljs-attr">orderId</span>: string;


  @IsString()
  <span class="hljs-attr">currency</span>: string;


  @IsArray()
  @ArrayMinSize(<span class="hljs-number">1</span>)
  @ValidateNested({ <span class="hljs-attr">each</span>: <span class="hljs-literal">true</span> })
  @Type( <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> PaymentSessionItemDto )
  <span class="hljs-attr">items</span>: PaymentSessionItemDto[];

}


<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentSessionItemDto</span> </span>{

  @IsString()
  <span class="hljs-attr">name</span>: string;

  @IsNumber()
  @IsPositive()
  <span class="hljs-attr">price</span>: number;

  @IsNumber()
  @IsPositive()
  <span class="hljs-attr">quantity</span>: number;
}
</div></code></pre>
<ul>
<li>Ahora debo pasarle el objeto que pase la validación de los dto en orders.service</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">async</span> createPaymentSession(order: OrderWithProducts) {

  <span class="hljs-keyword">const</span> paymentSession = <span class="hljs-keyword">await</span> firstValueFrom(
    <span class="hljs-keyword">this</span>.client.send(<span class="hljs-string">'create.payment.session'</span>, {
       <span class="hljs-comment">//abc: 123,</span>
       <span class="hljs-comment">//xyz:234</span>
      <span class="hljs-attr">orderId</span>: order.id,
      <span class="hljs-attr">currency</span>: <span class="hljs-string">'usd'</span>,
      <span class="hljs-attr">items</span>: [
        {
          <span class="hljs-attr">name</span>: <span class="hljs-string">'ksjsjhs'</span>.
          price:<span class="hljs-number">200</span>,
          <span class="hljs-attr">quantity</span>: <span class="hljs-number">300</span>
        }
      ]
      ,
    }),
  );

  <span class="hljs-keyword">return</span> paymentSession;
}
</div></code></pre>
<hr>
<h2 id="retornar-urls-de-sesi%C3%B3n">Retornar URLS de sesión</h2>
<ul>
<li>En lugar de enviar en duro el producto, debe recibir lo que hay en items</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">async</span> createPaymentSession(order: OrderWithProducts) {

  <span class="hljs-keyword">const</span> paymentSession = <span class="hljs-keyword">await</span> firstValueFrom(
    <span class="hljs-keyword">this</span>.client.send(<span class="hljs-string">'create.payment.session'</span>, {
      <span class="hljs-attr">orderId</span>: order.id,
      <span class="hljs-attr">currency</span>: <span class="hljs-string">'usd'</span>,
      <span class="hljs-attr">items</span>: order.OrderItem.map( <span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> ({
        <span class="hljs-attr">name</span>: item.name,
        <span class="hljs-attr">price</span>: item.price,
        <span class="hljs-attr">quantity</span>: item.quantity,
      }) ),
    }),
  );

  <span class="hljs-keyword">return</span> paymentSession;
}
</div></code></pre>
<ul>
<li>Entonces, ya estamos llegando al payments-ms.controller, recogemos el paymentsDto con @Payload</li>
<li>En payments.service</li>
</ul>
<pre class="hljs"><code><div> <span class="hljs-keyword">async</span> createPaymentSession(paymentSessionDto: PaymentSessionDto) {
    <span class="hljs-keyword">const</span> { currency, items, orderId } = paymentSessionDto;

    <span class="hljs-keyword">const</span> lineItems = items.map(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">price_data</span>: {
          <span class="hljs-attr">currency</span>: currency,
          <span class="hljs-attr">product_data</span>: {
            <span class="hljs-attr">name</span>: item.name,
          },
          <span class="hljs-attr">unit_amount</span>: <span class="hljs-built_in">Math</span>.round(item.price * <span class="hljs-number">100</span>), <span class="hljs-comment">// 20 dólares 2000 / 100 = 20.00 // 15.0000</span>
        },
        <span class="hljs-attr">quantity</span>: item.quantity,
      };
    });

    <span class="hljs-keyword">const</span> session = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.stripe.checkout.sessions.create({
      <span class="hljs-comment">// Colocar aquí el ID de mi orden</span>
      <span class="hljs-attr">payment_intent_data</span>: {
        <span class="hljs-attr">metadata</span>: {
          <span class="hljs-attr">orderId</span>: orderId
        },
      },
      <span class="hljs-attr">line_items</span>: lineItems,
      <span class="hljs-attr">mode</span>: <span class="hljs-string">'payment'</span>,
      <span class="hljs-attr">success_url</span>: envs.stripeSuccessUrl,
      <span class="hljs-attr">cancel_url</span>: envs.stripeCancelUrl,
    });

    <span class="hljs-comment">//Si apunto al endpoint 3000/api/orders tengo muchisima info en la respuesta si retorno la sesión, más de la que necesito</span>
    <span class="hljs-comment">// return session;</span>
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">cancelUrl</span>: session.cancel_url,
      <span class="hljs-attr">successUrl</span>: session.success_url, 
      <span class="hljs-attr">url</span>: session.url, <span class="hljs-comment">//enlace para pagar</span>
    }
  }  
</div></code></pre>
<ul>
<li>Cuando la orden es creada hace la solicitud al payments para que hable con stripe  yme dé el session url</li>
<li>Por el mismo canal llega a orders para regresarle al cliente. Esta es la primera fase</li>
<li>Una vez realizado el pago tenemos que asegurarnos de comunicarnos con el webhook para que comunique a orders la orden pagada y recoger el recibo</li>
</ul>
<hr>
<h2 id="eventpattern">EventPattern</h2>
<ul>
<li>Corro con ngrok el proxy para levantar el forwarder y disponer de la URL para el webhook de Stripe</li>
<li>En payments.service creo el payload con la data</li>
<li>Creo una nueva instancia de un logger y le paso el payload para chequearlo</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">async</span> stripeWebhook(req: Request, <span class="hljs-attr">res</span>: Response) {
    <span class="hljs-keyword">const</span> sig = req.headers[<span class="hljs-string">'stripe-signature'</span>];

    <span class="hljs-keyword">let</span> event: Stripe.Event;

    <span class="hljs-comment">// Real</span>
    <span class="hljs-keyword">const</span> endpointSecret = envs.stripeEndpointSecret;

    <span class="hljs-keyword">try</span> {
      event = <span class="hljs-keyword">this</span>.stripe.webhooks.constructEvent(
        req[<span class="hljs-string">'rawBody'</span>],
        sig,
        endpointSecret,
      );
    } <span class="hljs-keyword">catch</span> (err) {
      res.status(<span class="hljs-number">400</span>).send(<span class="hljs-string">`Webhook Error: <span class="hljs-subst">${err.message}</span>`</span>);
      <span class="hljs-keyword">return</span>;
    }
    
    <span class="hljs-keyword">switch</span>( event.type ) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">'charge.succeeded'</span>: 
        <span class="hljs-keyword">const</span> chargeSucceeded = event.data.object;
        <span class="hljs-keyword">const</span> payload = {                     <span class="hljs-comment">//creo el payload</span>
          <span class="hljs-attr">stripePaymentId</span>: chargeSucceeded.id, 
          <span class="hljs-attr">orderId</span>: chargeSucceeded.metadata.orderId,
          <span class="hljs-attr">receiptUrl</span>: chargeSucceeded.receipt_url,
        }

         <span class="hljs-keyword">this</span>.logger.log({ payload }); <span class="hljs-comment">//chequeo el pyload con el logger</span>
       
      <span class="hljs-keyword">break</span>;
      
      <span class="hljs-keyword">default</span>:
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Event <span class="hljs-subst">${ event.type }</span> not handled`</span>);
    }

    <span class="hljs-keyword">return</span> res.status(<span class="hljs-number">200</span>).json({ sig });
  }
</div></code></pre>
<ul>
<li>Copio la carpeta transports con nats.module</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Module } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { ClientsModule, Transport } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/microservices'</span>;
<span class="hljs-keyword">import</span> { NATS_SERVICE, envs } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/config'</span>;

@Module({
  <span class="hljs-attr">imports</span>: [
    ClientsModule.register([
      {
        <span class="hljs-attr">name</span>: NATS_SERVICE,
        <span class="hljs-attr">transport</span>: Transport.NATS,
        <span class="hljs-attr">options</span>: {
          <span class="hljs-attr">servers</span>: envs.natsServers,
        },
      },
    ]),
  ],
  <span class="hljs-attr">exports</span>: [
    ClientsModule.register([
      {
        <span class="hljs-attr">name</span>: NATS_SERVICE,
        <span class="hljs-attr">transport</span>: Transport.NATS,
        <span class="hljs-attr">options</span>: {
          <span class="hljs-attr">servers</span>: envs.natsServers,
        },
      },
    ]),
  ],
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NatsModule</span> </span>{}
</div></code></pre>
<ul>
<li>En imports de payments-ms.module en src/payments (no app.module) coloco el NatsModule</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Module } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { PaymentsService } <span class="hljs-keyword">from</span> <span class="hljs-string">'./payments.service'</span>;
<span class="hljs-keyword">import</span> { PaymentsController } <span class="hljs-keyword">from</span> <span class="hljs-string">'./payments.controller'</span>;
<span class="hljs-keyword">import</span> { NatsModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/transports/nats.module'</span>;

@Module({
  <span class="hljs-attr">controllers</span>: [PaymentsController],
  <span class="hljs-attr">providers</span>: [PaymentsService],
  <span class="hljs-attr">imports</span>: [NatsModule],
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentsModule</span> </span>{}
</div></code></pre>
<ul>
<li>En el PaymentsService inyecto el NATS</li>
</ul>
<pre class="hljs"><code><div>@Injectable()
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentsService</span> </span>{

  private readonly stripe = <span class="hljs-keyword">new</span> Stripe(envs.stripeSecret);
  private readonly logger = <span class="hljs-keyword">new</span> Logger(<span class="hljs-string">'PaymentsService'</span>);

  <span class="hljs-keyword">constructor</span>(
    @Inject(NATS_SERVICE) private readonly client: ClientProxy
  ) {}

}
</div></code></pre>
<ul>
<li>Uso .emit porque no espero respuesta</li>
<li>Todavía no hay nadie que escuche el payment.succeeded</li>
</ul>
<pre class="hljs"><code><div> <span class="hljs-keyword">async</span> stripeWebhook(req: Request, <span class="hljs-attr">res</span>: Response) {
    <span class="hljs-keyword">const</span> sig = req.headers[<span class="hljs-string">'stripe-signature'</span>];

    <span class="hljs-keyword">let</span> event: Stripe.Event;

    <span class="hljs-comment">// Real</span>
    <span class="hljs-keyword">const</span> endpointSecret = envs.stripeEndpointSecret;

    <span class="hljs-keyword">try</span> {
      event = <span class="hljs-keyword">this</span>.stripe.webhooks.constructEvent(
        req[<span class="hljs-string">'rawBody'</span>],
        sig,
        endpointSecret,
      );
    } <span class="hljs-keyword">catch</span> (err) {
      res.status(<span class="hljs-number">400</span>).send(<span class="hljs-string">`Webhook Error: <span class="hljs-subst">${err.message}</span>`</span>);
      <span class="hljs-keyword">return</span>;
    }
    
    <span class="hljs-keyword">switch</span>( event.type ) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">'charge.succeeded'</span>: 
        <span class="hljs-keyword">const</span> chargeSucceeded = event.data.object;
        <span class="hljs-keyword">const</span> payload = {
          <span class="hljs-attr">stripePaymentId</span>: chargeSucceeded.id,
          <span class="hljs-attr">orderId</span>: chargeSucceeded.metadata.orderId,
          <span class="hljs-attr">receiptUrl</span>: chargeSucceeded.receipt_url,
        } <span class="hljs-comment">//este payload corresponderá al PaidOrderDTO</span>

        <span class="hljs-comment">// this.logger.log({ payload });</span>
        <span class="hljs-keyword">this</span>.client.emit(<span class="hljs-string">'payment.succeeded'</span>, payload ); <span class="hljs-comment">//todavía no hay nadie escuchando este evento</span>
      <span class="hljs-keyword">break</span>;
      
      <span class="hljs-keyword">default</span>:
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Event <span class="hljs-subst">${ event.type }</span> not handled`</span>);
    }

    <span class="hljs-keyword">return</span> res.status(<span class="hljs-number">200</span>).json({ sig });
  }
</div></code></pre>
<ul>
<li>En el orders-ms.controller (no en el cliente) escucho con EventPattern el payment.succeeded</li>
<li>Con el payload recoho la orden de pago, creo un dto para ella</li>
</ul>
<pre class="hljs"><code><div>@EventPattern(<span class="hljs-string">'payment.succeeded'</span>)
paidOrder(@Payload() paidOrderDto: PaidOrderDto ) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.ordersService.paidOrder( paidOrderDto );
}
</div></code></pre>
<ul>
<li>paidOrderDto</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { IsString, IsUUID, IsUrl } <span class="hljs-keyword">from</span> <span class="hljs-string">'class-validator'</span>;


<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaidOrderDto</span> </span>{

  @IsString()
  <span class="hljs-attr">stripePaymentId</span>:string;

  @IsString()
  @IsUUID()
  <span class="hljs-attr">orderId</span>: string;

  @IsString()
  @IsUrl()
  <span class="hljs-attr">receiptUrl</span>: string;


}
</div></code></pre>
<h2 id="preparar-base-de-datos-y-paidorderdto">Preparar base de datos y PaidOrderDto</h2>
<ul>
<li>En orders (mirto en TablePlus) puedo ver que tengo varios status, PENDING, DELIVERED; CANCELED</li>
<li>Para no tener todos los paidAt en NULL, tendriamos el paid en false y cuando estuviera en true estableceriamos la relacion uno a uno con otra tabla que diga pagada</li>
<li>En orders-ms/prisma en Order Status coloc PAID</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// This is your Prisma schema file,</span>
<span class="hljs-comment">// learn more about it in the docs: https://pris.ly/d/prisma-schema</span>

<span class="hljs-comment">// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?</span>
<span class="hljs-comment">// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init</span>

generator client {
  provider = <span class="hljs-string">"prisma-client-js"</span>
}

datasource db {
  provider = <span class="hljs-string">"postgresql"</span>
  url      = env(<span class="hljs-string">"DATABASE_URL"</span>)
}

enum OrderStatus {
  PENDING
  PAID
  DELIVERED
  CANCELLED
}

model Order {
  id          <span class="hljs-built_in">String</span> @id @<span class="hljs-keyword">default</span>(uuid())
  totalAmount Float
  totalItems  Int

  status         OrderStatus @<span class="hljs-keyword">default</span>(PENDING)
  paid           <span class="hljs-built_in">Boolean</span>     @<span class="hljs-keyword">default</span>(<span class="hljs-literal">false</span>)
  paidAt         DateTime?
  stripeChargeId <span class="hljs-built_in">String</span>?  

  createdAt DateTime @<span class="hljs-keyword">default</span>(now())
  updatedAt DateTime @updatedAt

  OrderItem    OrderItem[]
  OrderReceipt OrderReceipt? <span class="hljs-comment">//agrego OrderReceipt</span>
}

model OrderItem {
  id        <span class="hljs-built_in">String</span> @id @<span class="hljs-keyword">default</span>(uuid())
  productId Int
  quantity  Int
  price     Float

  Order   Order?  @relation(fields: [orderId], <span class="hljs-attr">references</span>: [id])
  orderId <span class="hljs-built_in">String</span>?
}

<span class="hljs-comment">//creo el orderReceipt (para guardar el recibo)</span>
model OrderReceipt {
  id <span class="hljs-built_in">String</span> @id @<span class="hljs-keyword">default</span>(uuid())

  order   Order  @relation(fields: [orderId], <span class="hljs-attr">references</span>: [id])
  orderId <span class="hljs-built_in">String</span> @unique <span class="hljs-comment">//me aseguro de que el orderId va a ser unico</span>

  receiptUrl <span class="hljs-built_in">String</span>

  createdAt DateTime @<span class="hljs-keyword">default</span>(now())
  updatedAt DateTime @updatedAt

}
</div></code></pre>
<ul>
<li>En el servicio creo paidOrder actualizo la order como pagada</li>
</ul>
<pre class="hljs"><code><div> <span class="hljs-keyword">async</span> paidOrder( paidOrderDto: PaidOrderDto ) {

    <span class="hljs-keyword">this</span>.logger.log(<span class="hljs-string">'Order Paid'</span>);
    <span class="hljs-keyword">this</span>.logger.log(paidOrderDto);

    <span class="hljs-keyword">const</span> order = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.order.update({
      <span class="hljs-attr">where</span>: { <span class="hljs-attr">id</span>: paidOrderDto.orderId },
      <span class="hljs-attr">data</span>: {
        <span class="hljs-attr">status</span>: <span class="hljs-string">'PAID'</span>,
        <span class="hljs-attr">paid</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">paidAt</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),
        <span class="hljs-attr">stripeChargeId</span>: paidOrderDto.stripePaymentId,

        <span class="hljs-comment">// La relación</span>
        <span class="hljs-attr">OrderReceipt</span>: {
          <span class="hljs-attr">create</span>: {
            <span class="hljs-attr">receiptUrl</span>: paidOrderDto.receiptUrl
          }
        }
      }
    });

    <span class="hljs-keyword">return</span> order;

  }
</div></code></pre>
<hr>
<h1 id="nest-microservicios---auth">NEST MICROSERVICIOS - AUTH</h1>
<ul>
<li>Creo el módulo de auth con nest new auth-ms (lo haremos asi de momento luego lo corregimos)</li>
<li>En el main configuro el NATS</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { NestFactory } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/core'</span>;
<span class="hljs-keyword">import</span> { AppModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.module'</span>;
<span class="hljs-keyword">import</span> { MicroserviceOptions, Transport } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/microservices'</span>;
<span class="hljs-keyword">import</span> { envs } <span class="hljs-keyword">from</span> <span class="hljs-string">'./config'</span>;
<span class="hljs-keyword">import</span> { ValidationPipe } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bootstrap</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">await</span> NestFactory.createMicroservice&lt;MicroserviceOptions&gt;(
    AppModule,
    {
      <span class="hljs-attr">transport</span>: Transport.NATS,
      <span class="hljs-attr">options</span>: {
        <span class="hljs-attr">servers</span>: envs.natsServers,
      },
    },
  );

  app.useGlobalPipes(
    <span class="hljs-keyword">new</span> ValidationPipe({
      <span class="hljs-attr">whitelist</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">forbidNonWhitelisted</span>: <span class="hljs-literal">true</span>,
    }),
  );

  <span class="hljs-keyword">await</span> app.listen();
}
bootstrap();

</div></code></pre>
<ul>
<li>En auth creo con <strong>nest g res auth --no spec</strong> Microservice (non-HTTP)</li>
<li>Voy a client-gateway y creo con <strong>nest g  res auth</strong> el módulo de auth</li>
<li>Ins</li>
<li>Instalo dotenv y joi</li>
<li>Configuro las variables de entorno</li>
</ul>
<pre class="hljs"><code><div>PORT=3004

# NATS_SERVERS=&quot;nats://localhost:4222,nats://localhost:4223&quot;
NATS_SERVERS=&quot;nats://localhost:4222&quot;


AUTH_DATABASE_URL=mongodb+srv://***:*****@auth-microservice-db.8bpm1ia.mongodb.net/AuthDB


JWT_SECRET=OtroStringSeguroIriaAQUI
</div></code></pre>
<ul>
<li>Configurar variables de entorno de auth-ms/src/config/envs.ts</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> <span class="hljs-string">'dotenv/config'</span>;

<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> joi <span class="hljs-keyword">from</span> <span class="hljs-string">'joi'</span>;

interface EnvVars {
  <span class="hljs-attr">PORT</span>: number;
  
  NATS_SERVERS: string[];

  JWT_SECRET: string;
}

<span class="hljs-keyword">const</span> envsSchema = joi.object({
  <span class="hljs-attr">PORT</span>: joi.number().required(),
  
  <span class="hljs-attr">NATS_SERVERS</span>: joi.array().items( joi.string() ).required(),
  <span class="hljs-attr">JWT_SECRET</span>: joi.string().required(),
})
.unknown(<span class="hljs-literal">true</span>);

<span class="hljs-keyword">const</span> { error, value } = envsSchema.validate({ 
  ...process.env,
  <span class="hljs-attr">NATS_SERVERS</span>: process.env.NATS_SERVERS?.split(<span class="hljs-string">','</span>)
});


<span class="hljs-keyword">if</span> ( error ) {
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Config validation error: <span class="hljs-subst">${ error.message }</span>`</span>);
}

<span class="hljs-keyword">const</span> envVars:EnvVars = value;


<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> envs = {
  <span class="hljs-attr">port</span>: envVars.PORT,

  <span class="hljs-attr">natsServers</span>: envVars.NATS_SERVERS,

  <span class="hljs-attr">jwtSecret</span>: envVars.JWT_SECRET,
};
</div></code></pre>
<ul>
<li>En el docker-compose conecto solo el auth</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-attr">version:</span> <span class="hljs-string">'3'</span>


<span class="hljs-attr">services:</span>

  
  <span class="hljs-attr">nats-server:</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">nats:latest</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">"8222:8222"</span>
    

  <span class="hljs-attr">client-gateway:</span>
    <span class="hljs-attr">build:</span> <span class="hljs-string">./client-gateway</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">${CLIENT_GATEWAY_PORT}:3000</span>
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">./client-gateway/src:/usr/src/app/src</span>
    <span class="hljs-attr">command:</span> <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">start:dev</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">PORT=3000</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">NATS_SERVERS=nats://nats-server:4222</span>

  <span class="hljs-attr">auth-ms:</span>
    <span class="hljs-attr">build:</span> <span class="hljs-string">./auth-ms</span>
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">./auth-ms/src:/usr/src/app/src</span>
    <span class="hljs-attr">command:</span> <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">start:dev</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">PORT=3004</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">NATS_SERVERS=nats://nats-server:4222</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">DATABASE_URL=${AUTH_DATABASE_URL}</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">JWT_SECRET=${JWT_SECRET}</span>

<span class="hljs-comment">#   products-ms:</span>
<span class="hljs-comment">#     build: ./products-ms</span>
<span class="hljs-comment">#     volumes:</span>
<span class="hljs-comment">#       - ./products-ms/src:/usr/src/app/src</span>
<span class="hljs-comment">#     command: npm run start:dev</span>
<span class="hljs-comment">#     environment:</span>
<span class="hljs-comment">#       - PORT=3001</span>
<span class="hljs-comment">#       - NATS_SERVERS=nats://nats-server:4222</span>
<span class="hljs-comment">#       - DATABASE_URL=file:./dev.db</span>

  
<span class="hljs-comment">#   # Orders MS</span>
<span class="hljs-comment">#   orders-ms:</span>
<span class="hljs-comment">#     depends_on:</span>
<span class="hljs-comment">#       - orders-db</span>
<span class="hljs-comment">#     build: ./orders-ms</span>
<span class="hljs-comment">#     volumes:</span>
<span class="hljs-comment">#       - ./orders-ms/src:/usr/src/app/src</span>
<span class="hljs-comment">#     command: npm run start:dev</span>
<span class="hljs-comment">#     environment:</span>
<span class="hljs-comment">#       - PORT=3002</span>
<span class="hljs-comment">#       - DATABASE_URL=postgresql://postgres:123456@orders-db:5432/ordersdb?schema=public</span>
<span class="hljs-comment">#       - NATS_SERVERS=nats://nats-server:4222</span>



<span class="hljs-comment">#   # Orders DB</span>
<span class="hljs-comment">#   orders-db:</span>
<span class="hljs-comment">#     container_name: orders_database</span>
<span class="hljs-comment">#     image: postgres:16.2</span>
<span class="hljs-comment">#     restart: always</span>
<span class="hljs-comment">#     volumes:</span>
<span class="hljs-comment">#       - ./orders-ms/postgres:/var/lib/postgresql/data</span>
<span class="hljs-comment">#     ports:</span>
<span class="hljs-comment">#       - 5432:5432</span>
<span class="hljs-comment">#     environment:</span>
<span class="hljs-comment">#       - POSTGRES_USER=postgres</span>
<span class="hljs-comment">#       - POSTGRES_PASSWORD=123456</span>
<span class="hljs-comment">#       - POSTGRES_DB=ordersdb</span>

<span class="hljs-comment"># # ======================</span>
<span class="hljs-comment"># # Payments Microservice</span>
<span class="hljs-comment"># # ======================</span>
<span class="hljs-comment">#   payments-ms:</span>
<span class="hljs-comment">#     container_name: payments-ms</span>
<span class="hljs-comment">#     build: ./payments-ms</span>
<span class="hljs-comment">#     volumes:</span>
<span class="hljs-comment">#       - ./payments-ms/src:/usr/src/app/src</span>
<span class="hljs-comment">#     command: npm run start:dev</span>
<span class="hljs-comment">#     ports:</span>
<span class="hljs-comment">#       - ${PAYMENTS_MS_PORT}:${PAYMENTS_MS_PORT}</span>
<span class="hljs-comment">#     environment:</span>
<span class="hljs-comment">#       - PORT=${PAYMENTS_MS_PORT}</span>
<span class="hljs-comment">#       - NATS_SERVERS=nats://nats-server:4222</span>
<span class="hljs-comment">#       - STRIPE_SECRET=${STRIPE_SECRET}</span>
<span class="hljs-comment">#       - STRIPE_SUCCESS_URL=${STRIPE_SUCCESS_URL}</span>
<span class="hljs-comment">#       - STRIPE_CANCEL_URL=${STRIPE_CANCEL_URL}</span>
<span class="hljs-comment">#       - STRIPE_ENDPOINT_SECRET=${STRIPE_ENDPOINT_SECRET}</span>
      
</div></code></pre>
<ul>
<li>Desde auth-ms.controller</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Controller } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { AuthService } <span class="hljs-keyword">from</span> <span class="hljs-string">'./auth.service'</span>;
<span class="hljs-keyword">import</span> { MessagePattern, Payload } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/microservices'</span>;
<span class="hljs-keyword">import</span> { LoginUserDto, RegisterUserDto } <span class="hljs-keyword">from</span> <span class="hljs-string">'./dto'</span>;

@Controller()
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthController</span> </span>{
  <span class="hljs-keyword">constructor</span>(private readonly authService: AuthService) {}
  <span class="hljs-comment">/*
    foo.* matches foo.bar, foo.baz, and so on, but not foo.bar.baz
    foo.*.bar matches foo.baz.bar, foo.qux.bar, and so on, but not foo.bar or foo.bar.baz
    foo.&gt; matches foo.bar, foo.bar.baz, and so on
  */</span>
  @MessagePattern(<span class="hljs-string">'auth.register.user'</span>)
  registerUser(@Payload() registerUserDto: RegisterUserDto) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.authService.registerUser(registerUserDto);
  }

  @MessagePattern(<span class="hljs-string">'auth.login.user'</span>)
  loginUser(@Payload() loginUserDto: LoginUserDto) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.authService.loginUser( loginUserDto );
  }

  @MessagePattern(<span class="hljs-string">'auth.verify.user'</span>)
  verifyToken( @Payload() token: string ) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.authService.verifyToken(token)
  }
}
</div></code></pre>
<ul>
<li>En el auth.module de NATS (client-gateway) coloco el módulo de auth en auth.controller</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Module } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;

<span class="hljs-keyword">import</span> { AuthController } <span class="hljs-keyword">from</span> <span class="hljs-string">'./auth.controller'</span>;
<span class="hljs-keyword">import</span> { NatsModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/transports/nats.module'</span>;

@Module({
  <span class="hljs-attr">controllers</span>: [AuthController],
  <span class="hljs-attr">imports</span>: [NatsModule],
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthModule</span> </span>{}
</div></code></pre>
<hr>
<h2 id="login-y-register-dtos">Login y register DTOS</h2>
<ul>
<li>Auth-ms va a dictar lo que necesita y el client se tendrá que adaptar</li>
<li>El login-user.dto y register-user.dto estarán en auth-ms y en el client</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { IsEmail, IsString, IsStrongPassword } <span class="hljs-keyword">from</span> <span class="hljs-string">'class-validator'</span>;


<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginUserDto</span> </span>{

  @IsString()
  @IsEmail()
  <span class="hljs-attr">email</span>:string;


  @IsString()
  @IsStrongPassword()
  <span class="hljs-attr">password</span>: string;


}
</div></code></pre>
<ul>
<li>register-user.dto</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { IsEmail, IsString, IsStrongPassword } <span class="hljs-keyword">from</span> <span class="hljs-string">'class-validator'</span>;


<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RegisterUserDto</span> </span>{

  @IsString()
  <span class="hljs-attr">name</span>: string;


  @IsString()
  @IsEmail()
  <span class="hljs-attr">email</span>:string;


  @IsString()
  @IsStrongPassword()
  <span class="hljs-attr">password</span>: string;

}
</div></code></pre>
<hr>
<ul>
<li>Tengo el endpoint  localhost:3000/api/auth/register</li>
<li>Lo mismo con login</li>
<li>En el main de auth-ms tengo configurado el useGlobalPipes</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { IsEmail, IsString, IsStrongPassword } <span class="hljs-keyword">from</span> <span class="hljs-string">'class-validator'</span>;


<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RegisterUserDto</span> </span>{

  @IsString()
  <span class="hljs-attr">name</span>: string;


  @IsString()
  @IsEmail()
  <span class="hljs-attr">email</span>:string;


  @IsString()
  @IsStrongPassword()
  <span class="hljs-attr">password</span>: string;


}
</div></code></pre>
<hr>
<h2 id="aprovisionar-mongodb">Aprovisionar MongoDB</h2>
<ul>
<li>Este es el string de conexion de mongoDB atlas</li>
</ul>
<pre class="hljs"><code><div>mongodb+srv://meikaku:123456abc@microservices.husof8a.mongodb.net/
</div></code></pre>
<hr>
<h2 id="conectar-prisma-con-mongo">Conectar prisma con Mongo</h2>
<ul>
<li>En auth-ms instalo prisma</li>
<li>Creo el schema</li>
<li>Instalo prisma (es de desarrollo, pongo -D) y genero el cliente</li>
</ul>
<blockquote>
<p>npx prisma init</p>
</blockquote>
<blockquote>
<p>npx prisma generate</p>
</blockquote>
<pre class="hljs"><code><div><span class="hljs-comment">// This is your Prisma schema file,</span>
<span class="hljs-comment">// learn more about it in the docs: https://pris.ly/d/prisma-schema</span>

<span class="hljs-comment">// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?</span>
<span class="hljs-comment">// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init</span>

generator client {
  provider = <span class="hljs-string">"prisma-client-js"</span>
}

datasource db {
  provider = <span class="hljs-string">"mongodb"</span>
  url      = env(<span class="hljs-string">"DATABASE_URL"</span>)
}

model User {
  id       <span class="hljs-built_in">String</span> @id @<span class="hljs-keyword">default</span>(auto()) @map(<span class="hljs-string">"_id"</span>) @db.ObjectId
  email    <span class="hljs-built_in">String</span> @unique
  name     <span class="hljs-built_in">String</span>
  password <span class="hljs-built_in">String</span>
}
</div></code></pre>
<ul>
<li>Los scripts</li>
</ul>
<pre class="hljs"><code><div> <span class="hljs-string">"start:dev"</span>: <span class="hljs-string">"npm run prisma:docker &amp;&amp; nest start --watch"</span>,
 <span class="hljs-string">"start:debug"</span>: <span class="hljs-string">"nest start --debug --watch"</span>,
</div></code></pre>
<ul>
<li>En el service</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Injectable, Logger, OnModuleInit } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { RpcException } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/microservices'</span>;
<span class="hljs-keyword">import</span> { PrismaClient } <span class="hljs-keyword">from</span> <span class="hljs-string">'@prisma/client'</span>;

<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> bcrypt <span class="hljs-keyword">from</span> <span class="hljs-string">'bcrypt'</span>;

<span class="hljs-keyword">import</span> { LoginUserDto, RegisterUserDto } <span class="hljs-keyword">from</span> <span class="hljs-string">'./dto'</span>;
<span class="hljs-keyword">import</span> { JwtService } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/jwt'</span>;
<span class="hljs-keyword">import</span> { JwtPayload } <span class="hljs-keyword">from</span> <span class="hljs-string">'./interfaces/jwt-payload.interface'</span>;
<span class="hljs-keyword">import</span> { envs } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/config'</span>;

@Injectable()
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PrismaClient</span> <span class="hljs-title">implements</span> <span class="hljs-title">OnModuleInit</span> </span>{
  private readonly logger = <span class="hljs-keyword">new</span> Logger(<span class="hljs-string">'AuthService'</span>);

  <span class="hljs-keyword">constructor</span>(private readonly jwtService: JwtService) {
    <span class="hljs-keyword">super</span>();
  }

  onModuleInit() {
    <span class="hljs-keyword">this</span>.$connect();
    <span class="hljs-keyword">this</span>.logger.log(<span class="hljs-string">'MongoDB connected'</span>);
  }

  <span class="hljs-keyword">async</span> signJWT(payload: JwtPayload) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.jwtService.sign(payload);
  }

  <span class="hljs-keyword">async</span> verifyToken(token: string) {
    <span class="hljs-keyword">try</span> {
      
      <span class="hljs-keyword">const</span> { sub, iat, exp, ...user } = <span class="hljs-keyword">this</span>.jwtService.verify(token, {
        <span class="hljs-attr">secret</span>: envs.jwtSecret,
      });

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">user</span>: user,
        <span class="hljs-attr">token</span>: <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.signJWT(user),
      }

    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-built_in">console</span>.log(error);
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException({
        <span class="hljs-attr">status</span>: <span class="hljs-number">401</span>,
        <span class="hljs-attr">message</span>: <span class="hljs-string">'Invalid token'</span>
      })
    }

  }

  <span class="hljs-keyword">async</span> registerUser(registerUserDto: RegisterUserDto) {
    <span class="hljs-keyword">const</span> { email, name, password } = registerUserDto;

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.user.findUnique({
        <span class="hljs-attr">where</span>: {
          email,
        },
      });

      <span class="hljs-keyword">if</span> (user) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException({
          <span class="hljs-attr">status</span>: <span class="hljs-number">400</span>,
          <span class="hljs-attr">message</span>: <span class="hljs-string">'User already exists'</span>,
        });
      }

      <span class="hljs-keyword">const</span> newUser = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.user.create({
        <span class="hljs-attr">data</span>: {
          <span class="hljs-attr">email</span>: email,
          <span class="hljs-attr">password</span>: bcrypt.hashSync(password, <span class="hljs-number">10</span>), <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> encriptar / hash</span>
          <span class="hljs-attr">name</span>: name,
        },
      });

      <span class="hljs-keyword">const</span> { <span class="hljs-attr">password</span>: __, ...rest } = newUser;

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">user</span>: rest,
        <span class="hljs-attr">token</span>: <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.signJWT(rest),
      };
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException({
        <span class="hljs-attr">status</span>: <span class="hljs-number">400</span>,
        <span class="hljs-attr">message</span>: error.message,
      });
    }
  }

  <span class="hljs-keyword">async</span> loginUser(loginUserDto: LoginUserDto) {
    <span class="hljs-keyword">const</span> { email, password } = loginUserDto;

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.user.findUnique({
        <span class="hljs-attr">where</span>: { email },
      });

      <span class="hljs-keyword">if</span> (!user) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException({
          <span class="hljs-attr">status</span>: <span class="hljs-number">400</span>,
          <span class="hljs-attr">message</span>: <span class="hljs-string">'User/Password not valid'</span>,
        });
      }

      <span class="hljs-keyword">const</span> isPasswordValid = bcrypt.compareSync(password, user.password);

      <span class="hljs-keyword">if</span> (!isPasswordValid) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException({
          <span class="hljs-attr">status</span>: <span class="hljs-number">400</span>,
          <span class="hljs-attr">message</span>: <span class="hljs-string">'User/Password not valid'</span>,
        });
      }

      <span class="hljs-keyword">const</span> { <span class="hljs-attr">password</span>: __, ...rest } = user;

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">user</span>: rest,
        <span class="hljs-attr">token</span>: <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.signJWT(rest),
      };
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException({
        <span class="hljs-attr">status</span>: <span class="hljs-number">400</span>,
        <span class="hljs-attr">message</span>: error.message,
      });
    }
  }
}
</div></code></pre>
<hr>
<h2 id="schema-con-prisma">Schema con prisma</h2>
<ul>
<li>Instalo prisma (es de desarrollo, pongo -D) y genero el cliente</li>
</ul>
<blockquote>
<p>npx prisma init</p>
</blockquote>
<blockquote>
<p>npx prisma generate</p>
</blockquote>
<pre class="hljs"><code><div><span class="hljs-comment">// This is your Prisma schema file,</span>
<span class="hljs-comment">// learn more about it in the docs: https://pris.ly/d/prisma-schema</span>

<span class="hljs-comment">// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?</span>
<span class="hljs-comment">// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init</span>

generator client {
  provider = <span class="hljs-string">"prisma-client-js"</span>
}

datasource db {
  provider = <span class="hljs-string">"mongodb"</span>
  url      = env(<span class="hljs-string">"DATABASE_URL"</span>)
}

model User {
  id       <span class="hljs-built_in">String</span> @id @<span class="hljs-keyword">default</span>(auto()) @map(<span class="hljs-string">"_id"</span>) @db.ObjectId
  email    <span class="hljs-built_in">String</span> @unique
  name     <span class="hljs-built_in">String</span>
  password <span class="hljs-built_in">String</span>
}
</div></code></pre>
<ul>
<li>En el json creo prisma:docker</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-string">"prisma:docker"</span>: <span class="hljs-string">"npx prisma generate"</span>,
<span class="hljs-string">"start:dev"</span>: <span class="hljs-string">"npm run prisma:docker &amp;&amp; nest start --watch"</span>,
</div></code></pre>

</body>
</html>
